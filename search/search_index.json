{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Wildboottest wildboottest implements multiple fast wild cluster bootstrap algorithms as developed in Roodman et al (2019) and MacKinnon, Nielsen & Webb (2022) . Functionality It has similar, but more limited functionality than Stata's boottest , R's fwildcusterboot or Julia's WildBootTests.jl . It supports The wild cluster bootstrap for OLS ( Cameron, Gelbach & Miller 2008 , Roodman et al (2019) ). Multiple new versions of the wild cluster bootstrap as described in MacKinnon, Nielsen & Webb (2022) , including the WCR13, WCR31, WCR33, WCU13, WCU31 and WCU33. CRV1 and CRV3 robust variance estimation, including the CRV3-Jackknife as described in MacKinnon, Nielsen & Webb (2022) . At the moment, wildboottest only computes wild cluster bootstrapped p-values , and no confidence intervals. Other features that are currently not supported: The (non-clustered) wild bootstrap for OLS ( Wu, 1986 ). The subcluster bootstrap ( MacKinnon and Webb 2018 ). Confidence intervals formed by inverting the test and iteratively searching for bounds. Multiway clustering. Direct support for statsmodels and linearmodels is work in progress. If you'd like to cooperate, either send us an email or comment in the issues section! Installation You can install wildboottest from PyPi by running pip install wildboottest Citation If you use wildboottest in your research, please consider citing it via @Unpublished{wildboottest2022, Title = {Fast Wild Cluster Bootstrap Inference in Python via wildboottest}, Author = {Alexander Fischer and Aleksandr Michuda}, Year = {2022}, Url = {https://github.com/s3alfisc/wildboottest} }","title":"Home"},{"location":"#welcome-to-wildboottest","text":"wildboottest implements multiple fast wild cluster bootstrap algorithms as developed in Roodman et al (2019) and MacKinnon, Nielsen & Webb (2022) .","title":"Welcome to Wildboottest"},{"location":"#functionality","text":"It has similar, but more limited functionality than Stata's boottest , R's fwildcusterboot or Julia's WildBootTests.jl . It supports The wild cluster bootstrap for OLS ( Cameron, Gelbach & Miller 2008 , Roodman et al (2019) ). Multiple new versions of the wild cluster bootstrap as described in MacKinnon, Nielsen & Webb (2022) , including the WCR13, WCR31, WCR33, WCU13, WCU31 and WCU33. CRV1 and CRV3 robust variance estimation, including the CRV3-Jackknife as described in MacKinnon, Nielsen & Webb (2022) . At the moment, wildboottest only computes wild cluster bootstrapped p-values , and no confidence intervals. Other features that are currently not supported: The (non-clustered) wild bootstrap for OLS ( Wu, 1986 ). The subcluster bootstrap ( MacKinnon and Webb 2018 ). Confidence intervals formed by inverting the test and iteratively searching for bounds. Multiway clustering. Direct support for statsmodels and linearmodels is work in progress. If you'd like to cooperate, either send us an email or comment in the issues section!","title":"Functionality"},{"location":"#installation","text":"You can install wildboottest from PyPi by running pip install wildboottest","title":"Installation"},{"location":"#citation","text":"If you use wildboottest in your research, please consider citing it via @Unpublished{wildboottest2022, Title = {Fast Wild Cluster Bootstrap Inference in Python via wildboottest}, Author = {Alexander Fischer and Aleksandr Michuda}, Year = {2022}, Url = {https://github.com/s3alfisc/wildboottest} }","title":"Citation"},{"location":"base/","text":"Create an object of Wildboottest and get p-value by successively applying methods in the following way: Example preliminaries: load libraries and create data import numpy as np from wildboottest.wildboottest import Wildboottest np.random.seed(12312312) N = 1000 k = 3 G = 10 X = np.random.normal(0, 1, N * k).reshape((N,k)) beta = np.random.normal(0,1,k) beta[0] = 0.005 u = np.random.normal(0,1,N) Y = 1 + X @ beta + u cluster = np.random.choice(list(range(0,G)), N) R = np.array([1, 0, 0]) B = 999 run the wild cluster bootstrap wb = Wildboottest(X = X, Y = Y, cluster = cluster, R = R, B = B) wb.get_scores(bootstrap_type = \"11\", impose_null = True) wb.get_weights(weights_type= \"rademacher\") wb.get_numer() wb.get_denom() wb.get_tboot() wb.get_vcov() wb.get_tstat() wb.get_pvalue() Source code in wildboottest\\wildboottest.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 class Wildboottest : \"\"\" Create an object of Wildboottest and get p-value by successively applying methods in the following way: Example: >>> # preliminaries: load libraries and create data >>> import numpy as np >>> from wildboottest.wildboottest import Wildboottest >>> np.random.seed(12312312) >>> N = 1000 >>> k = 3 >>> G = 10 >>> X = np.random.normal(0, 1, N * k).reshape((N,k)) >>> beta = np.random.normal(0,1,k) >>> beta[0] = 0.005 >>> u = np.random.normal(0,1,N) >>> Y = 1 + X @ beta + u >>> cluster = np.random.choice(list(range(0,G)), N) >>> R = np.array([1, 0, 0]) >>> B = 999 >>> # run the wild cluster bootstrap >>> wb = Wildboottest(X = X, Y = Y, cluster = cluster, R = R, B = B) >>> wb.get_scores(bootstrap_type = \"11\", impose_null = True) >>> wb.get_weights(weights_type= \"rademacher\") >>> wb.get_numer() >>> wb.get_denom() >>> wb.get_tboot() >>> wb.get_vcov() >>> wb.get_tstat() >>> wb.get_pvalue() \"\"\" def __init__ ( self , X : Union [ np . ndarray , pd . DataFrame , pd . Series ], Y : Union [ np . ndarray , pd . DataFrame , pd . Series ], cluster : Union [ np . ndarray , pd . DataFrame , pd . Series ], R : Union [ np . ndarray , pd . DataFrame ], B : int , bootcluster : Union [ np . ndarray , pd . DataFrame , pd . Series , None ] = None , seed : Union [ int , None ] = None ) -> None : \"\"\"Initializes the Wild Cluster Bootstrap Class Args: X (Union[np.ndarray, pd.DataFrame, pd.Series]): Exogeneous variable array or dataframe Y (Union[np.ndarray, pd.DataFrame, pd.Series]): Endogenous variable array or dataframe cluster (Union[np.ndarray, pd.DataFrame, pd.Series]): Cluster array or dataframe R (Union[np.ndarray, pd.DataFrame]): Constraint matrix for running bootstrap B (int): bootstrap iterations bootcluster (Union[np.ndarray, pd.DataFrame, pd.Series, None], optional): Sub-cluster array. Defaults to None. seed (Union[int, None], optional): Random seed for random weight types. Defaults to None. Raises: TypeError: Raise if input arrays are lists TestMatrixNonConformabilityException: Raise if constraint matrix shape does not conform to X \"\"\" \"Initialize the wildboottest class\" #assert bootstrap_type in ['11', '13', '31', '33'] #assert impose_null in [True, False] if bootcluster is None : bootcluster = cluster for i in [ X , Y , cluster , bootcluster ]: if isinstance ( i , list ): raise TypeError ( f \" { i } cannot be a list\" ) if isinstance ( X , ( pd . DataFrame , pd . Series )): self . X = X . values else : self . X = X if isinstance ( Y , ( pd . DataFrame , pd . Series )): self . Y = Y . values else : self . Y = Y if isinstance ( cluster , pd . DataFrame ): self . clustid = cluster . unique () self . cluster = cluster . values if isinstance ( bootcluster , pd . DataFrame ): self . bootclustid = bootcluster . unique () self . bootcluster = bootcluster . values else : self . clustid = np . unique ( cluster ) self . bootclustid = np . unique ( bootcluster ) self . bootcluster = bootcluster if isinstance ( seed , int ): np . random . seed ( seed ) self . N_G_bootcluster = len ( self . bootclustid ) self . G = len ( self . clustid ) self . N = X . shape [ 0 ] self . k = X . shape [ 1 ] self . B = B self . R = R if self . X . shape [ 1 ] != self . R . shape [ 0 ]: raise TestMatrixNonConformabilityException ( \"The number of rows in the test matrix R, does not \" ) X_list = [] y_list = [] tXgXg_list = [] tXgyg_list = [] tXX = np . zeros (( self . k , self . k )) tXy = np . zeros ( self . k ) #all_cluster = np.unique(bootcluster) for g in self . bootclustid : # split X and Y by (boot)cluster X_g = self . X [ np . where ( self . bootcluster == g )] Y_g = self . Y [ np . where ( self . bootcluster == g )] tXgXg = np . transpose ( X_g ) @ X_g tXgyg = np . transpose ( X_g ) @ Y_g X_list . append ( X_g ) y_list . append ( Y_g ) tXgXg_list . append ( tXgXg ) tXgyg_list . append ( tXgyg ) tXX = tXX + tXgXg tXy = tXy + tXgyg self . X_list = X_list self . Y_list = y_list self . tXgXg_list = tXgXg_list self . tXgyg_list = tXgyg_list self . tXX = tXX self . tXy = tXy self . tXXinv = np . linalg . inv ( tXX ) self . RtXXinv = np . matmul ( R , self . tXXinv ) def get_weights ( self , weights_type : Union [ str , Callable ]) -> Tuple [ np . ndarray , int , bool ]: \"\"\"Function for getting weights for bootstrapping. Args: weights_type (Tuple[str, Callable]): The distribution to be used. Accepts Either 'rademacher', 'mammen', 'norm' or 'webb'. Optionally accepts a callable of one argument, `n`, the number of bootstraps iterations. Returns: Tuple[np.ndarray, int]: Returns the arrays of weights and the number of bootstrap iterations \"\"\" self . weights_type = weights_type if 2 ** self . N_G_bootcluster < self . B and weights_type == 'rademacher' : self . full_enumeration = True full_enumeration_warn = True else : self . full_enumeration = False full_enumeration_warn = False self . v , self . B = draw_weights ( t = self . weights_type , full_enumeration = self . full_enumeration , N_G_bootcluster = self . N_G_bootcluster , boot_iter = self . B ) return self . v , self . B , full_enumeration_warn def get_scores ( self , bootstrap_type : str , impose_null : bool , adj : bool = True , cluster_adj : bool = True ) -> np . ndarray : \"\"\"Run bootstrap and get scores for each variable Args: bootstrap_type (str): Determines which wild cluster bootstrap type should be run. Options are \"fnw11\",\"11\", \"13\", \"31\" and \"33\" for the wild cluster bootstrap and \"11\" and \"31\" for the heteroskedastic bootstrap. For more information, see the details section. \"fnw11\" is the default for the cluster bootstrap, which runs a \"11\" type wild cluster bootstrap via the algorithm outlined in \"fast and wild\" (Roodman et al (2019)). \"11\" is the default for the heteroskedastic bootstrap. impose_null (bool): Controls if the null hypothesis is imposed on the bootstrap dgp or not. Null imposed (WCR) by default. If False, the null is not imposed (WCU) adj (bool, optional): Whether to adjust for small sample. Defaults to True. cluster_adj (bool, optional): Whether to do a cluster-robust small sample correction. Defaults to True. Returns: np.ndarray: The output array of scores of shape kxG \"\"\" if bootstrap_type [ 1 : 2 ] == '1' : self . crv_type = \"crv1\" self . ssc = 1 if adj : self . ssc = self . ssc * ( self . N - 1 ) / ( self . N - self . k ) if cluster_adj : self . ssc = self . ssc * self . G / ( self . G - 1 ) elif bootstrap_type [ 1 : 2 ] == '3' : self . crv_type = \"crv3\" self . ssc = ( self . G - 1 ) / self . G bootstrap_type_x = bootstrap_type [ 0 : 1 ] + 'x' if impose_null == True : self . bootstrap_type = \"WCR\" + bootstrap_type_x else : self . bootstrap_type = \"WCU\" + bootstrap_type_x # not needed for all types, but compute anyways self . beta_hat = self . tXXinv @ self . tXy # precompute required objects for computing scores & vcov's if self . bootstrap_type in [ \"WCR3x\" ]: X = self . X X1 = X [:, self . R == 0 ] X1_list = [] tX1gX1g_list = [] tX1gyg_list = [] tXgX1g_list = [] tX1X1 = np . zeros (( self . k - 1 , self . k - 1 )) tX1y = np . zeros ( self . k - 1 ) for ix , g in enumerate ( self . bootclustid ): #ix = g = 1 X1_list . append ( X1 [ np . where ( self . bootcluster == g )]) tX1gX1g_list . append ( np . transpose ( X1_list [ ix ]) @ X1_list [ ix ]) tX1gyg_list . append ( np . transpose ( X1_list [ ix ]) @ self . Y_list [ ix ]) tXgX1g_list . append ( np . transpose ( self . X_list [ ix ]) @ X1_list [ ix ]) tX1X1 = tX1X1 + tX1gX1g_list [ ix ] tX1y = tX1y + tX1gyg_list [ ix ] beta_1g_tilde = [] for ix , g in enumerate ( self . bootclustid ): beta_1g_tilde . append ( np . linalg . pinv ( tX1X1 - tX1gX1g_list [ ix ]) @ ( tX1y - tX1gyg_list [ ix ])) beta = beta_1g_tilde M = tXgX1g_list elif self . bootstrap_type in [ \"WCU3x\" ]: beta_g_hat = [] for ix , g in enumerate ( self . bootclustid ): beta_g_hat . append ( np . linalg . pinv ( self . tXX - self . tXgXg_list [ ix ]) @ ( self . tXy - self . tXgyg_list [ ix ])) beta = beta_g_hat M = self . tXgXg_list elif self . bootstrap_type in [ \"WCR1x\" ]: A = 1 / ( np . transpose ( self . R ) @ self . tXXinv @ self . R ) beta_tilde = self . beta_hat - self . tXXinv @ self . R * A * ( self . R @ self . beta_hat - 0 ) beta = beta_tilde M = self . tXgXg_list elif self . bootstrap_type in [ \"WCU1x\" ]: beta = self . beta_hat M = self . tXgXg_list # compute scores based on tXgyg, M, beta scores_list = [] if ( self . bootstrap_type in [ \"WCR1x\" , \"WCU1x\" ]): for ix , g in enumerate ( self . bootclustid ): scores_list . append ( self . tXgyg_list [ ix ] - M [ ix ] @ beta ) elif ( self . bootstrap_type in [ \"WCR3x\" , \"WCU3x\" ]): for ix , g in enumerate ( self . bootclustid ): scores_list . append ( self . tXgyg_list [ ix ] - M [ ix ] @ beta [ ix ]) self . scores_mat = np . transpose ( np . array ( scores_list )) # k x G return self . scores_mat def get_numer ( self ): # Calculate the bootstrap numerator self . Cg = self . R @ self . tXXinv @ self . scores_mat self . numer = self . Cg @ self . v def get_denom ( self ): if self . crv_type == \"crv1\" : H = np . zeros (( self . G , self . G )) # numba optimization possible? for ixg , g in enumerate ( self . bootclustid ): for ixh , h in enumerate ( self . bootclustid ): # can be improved by replacing list calls with matrices; H [ ixg , ixh ] = self . R @ self . tXXinv @ self . tXgXg_list [ ixg ] @ self . tXXinv @ self . scores_mat [:, ixh ] # now compute denominator # numba / cython / c++ optimization possible? Porting this part from # R to c++ gives good speed improvements @jit def compute_denom ( Cg , H , bootclustid , B , G , v , ssc ): denom = np . zeros ( B + 1 ) for b in range ( 0 , B + 1 ): Zg = np . zeros ( G ) for ixg , g in enumerate ( bootclustid ): vH = 0 for ixh , h in enumerate ( bootclustid ): vH += v [ ixh , b ] * H [ ixg , ixh ] Zg [ ixg ] = Cg [ ixg ] * v [ ixg , b ] - vH # todo: ssc denom [ b ] = ssc * np . sum ( np . power ( Zg , 2 )) return denom self . denom = compute_denom ( self . Cg , H , self . bootclustid , self . B , self . G , self . v , self . ssc ) elif self . crv_type == \"crv3\" : self . inv_tXX_tXgXg = [] for ix , g in enumerate ( self . bootclustid ): self . inv_tXX_tXgXg . append ( np . linalg . pinv ( self . tXX - self . tXgXg_list [ ix ])) self . denom = np . zeros ( self . B + 1 ) for b in range ( 0 , self . B + 1 ): scores_g_boot = np . zeros (( self . G , self . k )) v_ = self . v [:, b ] for ixg , g in enumerate ( self . bootclustid ): scores_g_boot [ ixg ,:] = self . scores_mat [:, ixg ] * v_ [ ixg ] scores_boot = np . sum ( scores_g_boot , axis = 0 ) delta_b_star = self . tXXinv @ scores_boot delta_diff = np . zeros (( self . G , self . k )) for ixg , g in enumerate ( self . bootclustid ): score_diff = scores_boot - scores_g_boot [ ixg ,:] delta_diff [ ixg ,:] = ( ( self . inv_tXX_tXgXg [ ixg ] @ score_diff - delta_b_star ) ** 2 ) # se's self . denom [ b ] = self . ssc * np . sum ( delta_diff , axis = 0 )[ np . where ( self . R == 1 )] def get_tboot ( self ): t_boot = self . numer / np . sqrt ( self . denom ) self . t_boot = t_boot [ 1 :( self . B + 1 )] # drop first element - might be useful for comp. of def get_vcov ( self ): if self . crv_type == \"crv1\" : meat = np . zeros (( self . k , self . k )) for ixg , g in enumerate ( self . bootclustid ): score = np . transpose ( self . X_list [ ixg ]) @ ( self . Y_list [ ixg ] - self . X_list [ ixg ] @ self . beta_hat ) meat += np . outer ( score , score ) self . vcov = self . tXXinv @ meat @ self . tXXinv elif self . crv_type == \"crv3\" : # calculate leave-one out beta hat beta_jack = np . zeros (( self . G , self . k )) for ixg , g in enumerate ( self . bootclustid ): beta_jack [ ixg ,:] = ( np . linalg . pinv ( self . tXX - self . tXgXg_list [ ixg ]) @ ( self . tXy - np . transpose ( self . X_list [ ixg ]) @ self . Y_list [ ixg ]) ) if not hasattr ( self , \"beta_hat\" ): beta_hat = self . tXXinv @ self . tXy beta_center = self . beta_hat vcov3 = np . zeros (( self . k , self . k )) for ixg , g in enumerate ( self . bootclustid ): beta_centered = beta_jack [ ixg ,:] - beta_center vcov3 += np . outer ( beta_centered , beta_centered ) self . vcov = vcov3 def get_tstat ( self ): se = np . sqrt ( self . ssc * self . R @ self . vcov @ np . transpose ( self . R )) t_stats = self . beta_hat / se self . t_stat = t_stats [ np . where ( self . R == 1 )] def get_pvalue ( self , pval_type = \"two-tailed\" ): if pval_type == \"two-tailed\" : self . pvalue = np . mean ( np . abs ( self . t_stat ) < abs ( self . t_boot )) elif pval_type == \"equal-tailed\" : pl = np . mean ( self . t_stat < self . t_boot ) ph = np . mean ( self . t_stat > self . t_boot ) self . pvalue = 2 * min ( pl , ph ) elif pval_type == \">\" : self . pvalue = np . mean ( self . t_stat < self . t_boot ) else : self . pvalue = np . mean ( self . t_stat > self . t_boot ) __init__ ( X , Y , cluster , R , B , bootcluster = None , seed = None ) Initializes the Wild Cluster Bootstrap Class Parameters: Name Type Description Default X Union [ np . ndarray , pd . DataFrame , pd . Series ] Exogeneous variable array or dataframe required Y Union [ np . ndarray , pd . DataFrame , pd . Series ] Endogenous variable array or dataframe required cluster Union [ np . ndarray , pd . DataFrame , pd . Series ] Cluster array or dataframe required R Union [ np . ndarray , pd . DataFrame ] Constraint matrix for running bootstrap required B int bootstrap iterations required bootcluster Union [ np . ndarray , pd . DataFrame , pd . Series , None] Sub-cluster array. Defaults to None. None seed Union [ int , None] Random seed for random weight types. Defaults to None. None Raises: Type Description TypeError Raise if input arrays are lists TestMatrixNonConformabilityException Raise if constraint matrix shape does not conform to X Source code in wildboottest\\wildboottest.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def __init__ ( self , X : Union [ np . ndarray , pd . DataFrame , pd . Series ], Y : Union [ np . ndarray , pd . DataFrame , pd . Series ], cluster : Union [ np . ndarray , pd . DataFrame , pd . Series ], R : Union [ np . ndarray , pd . DataFrame ], B : int , bootcluster : Union [ np . ndarray , pd . DataFrame , pd . Series , None ] = None , seed : Union [ int , None ] = None ) -> None : \"\"\"Initializes the Wild Cluster Bootstrap Class Args: X (Union[np.ndarray, pd.DataFrame, pd.Series]): Exogeneous variable array or dataframe Y (Union[np.ndarray, pd.DataFrame, pd.Series]): Endogenous variable array or dataframe cluster (Union[np.ndarray, pd.DataFrame, pd.Series]): Cluster array or dataframe R (Union[np.ndarray, pd.DataFrame]): Constraint matrix for running bootstrap B (int): bootstrap iterations bootcluster (Union[np.ndarray, pd.DataFrame, pd.Series, None], optional): Sub-cluster array. Defaults to None. seed (Union[int, None], optional): Random seed for random weight types. Defaults to None. Raises: TypeError: Raise if input arrays are lists TestMatrixNonConformabilityException: Raise if constraint matrix shape does not conform to X \"\"\" \"Initialize the wildboottest class\" #assert bootstrap_type in ['11', '13', '31', '33'] #assert impose_null in [True, False] if bootcluster is None : bootcluster = cluster for i in [ X , Y , cluster , bootcluster ]: if isinstance ( i , list ): raise TypeError ( f \" { i } cannot be a list\" ) if isinstance ( X , ( pd . DataFrame , pd . Series )): self . X = X . values else : self . X = X if isinstance ( Y , ( pd . DataFrame , pd . Series )): self . Y = Y . values else : self . Y = Y if isinstance ( cluster , pd . DataFrame ): self . clustid = cluster . unique () self . cluster = cluster . values if isinstance ( bootcluster , pd . DataFrame ): self . bootclustid = bootcluster . unique () self . bootcluster = bootcluster . values else : self . clustid = np . unique ( cluster ) self . bootclustid = np . unique ( bootcluster ) self . bootcluster = bootcluster if isinstance ( seed , int ): np . random . seed ( seed ) self . N_G_bootcluster = len ( self . bootclustid ) self . G = len ( self . clustid ) self . N = X . shape [ 0 ] self . k = X . shape [ 1 ] self . B = B self . R = R if self . X . shape [ 1 ] != self . R . shape [ 0 ]: raise TestMatrixNonConformabilityException ( \"The number of rows in the test matrix R, does not \" ) X_list = [] y_list = [] tXgXg_list = [] tXgyg_list = [] tXX = np . zeros (( self . k , self . k )) tXy = np . zeros ( self . k ) #all_cluster = np.unique(bootcluster) for g in self . bootclustid : # split X and Y by (boot)cluster X_g = self . X [ np . where ( self . bootcluster == g )] Y_g = self . Y [ np . where ( self . bootcluster == g )] tXgXg = np . transpose ( X_g ) @ X_g tXgyg = np . transpose ( X_g ) @ Y_g X_list . append ( X_g ) y_list . append ( Y_g ) tXgXg_list . append ( tXgXg ) tXgyg_list . append ( tXgyg ) tXX = tXX + tXgXg tXy = tXy + tXgyg self . X_list = X_list self . Y_list = y_list self . tXgXg_list = tXgXg_list self . tXgyg_list = tXgyg_list self . tXX = tXX self . tXy = tXy self . tXXinv = np . linalg . inv ( tXX ) self . RtXXinv = np . matmul ( R , self . tXXinv ) get_scores ( bootstrap_type , impose_null , adj = True , cluster_adj = True ) Run bootstrap and get scores for each variable Parameters: Name Type Description Default bootstrap_type str Determines which wild cluster bootstrap type should be run. Options are \"fnw11\",\"11\", \"13\", \"31\" and \"33\" for the wild cluster bootstrap and \"11\" and \"31\" for the heteroskedastic bootstrap. For more information, see the details section. \"fnw11\" is the default for the cluster bootstrap, which runs a \"11\" type wild cluster bootstrap via the algorithm outlined in \"fast and wild\" (Roodman et al (2019)). \"11\" is the default for the heteroskedastic bootstrap. required impose_null bool Controls if the null hypothesis is imposed on the bootstrap dgp or not. Null imposed (WCR) by default. If False, the null is not imposed (WCU) required adj bool Whether to adjust for small sample. Defaults to True. True cluster_adj bool Whether to do a cluster-robust small sample correction. Defaults to True. True Returns: Type Description np . ndarray np.ndarray: The output array of scores of shape kxG Source code in wildboottest\\wildboottest.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 def get_scores ( self , bootstrap_type : str , impose_null : bool , adj : bool = True , cluster_adj : bool = True ) -> np . ndarray : \"\"\"Run bootstrap and get scores for each variable Args: bootstrap_type (str): Determines which wild cluster bootstrap type should be run. Options are \"fnw11\",\"11\", \"13\", \"31\" and \"33\" for the wild cluster bootstrap and \"11\" and \"31\" for the heteroskedastic bootstrap. For more information, see the details section. \"fnw11\" is the default for the cluster bootstrap, which runs a \"11\" type wild cluster bootstrap via the algorithm outlined in \"fast and wild\" (Roodman et al (2019)). \"11\" is the default for the heteroskedastic bootstrap. impose_null (bool): Controls if the null hypothesis is imposed on the bootstrap dgp or not. Null imposed (WCR) by default. If False, the null is not imposed (WCU) adj (bool, optional): Whether to adjust for small sample. Defaults to True. cluster_adj (bool, optional): Whether to do a cluster-robust small sample correction. Defaults to True. Returns: np.ndarray: The output array of scores of shape kxG \"\"\" if bootstrap_type [ 1 : 2 ] == '1' : self . crv_type = \"crv1\" self . ssc = 1 if adj : self . ssc = self . ssc * ( self . N - 1 ) / ( self . N - self . k ) if cluster_adj : self . ssc = self . ssc * self . G / ( self . G - 1 ) elif bootstrap_type [ 1 : 2 ] == '3' : self . crv_type = \"crv3\" self . ssc = ( self . G - 1 ) / self . G bootstrap_type_x = bootstrap_type [ 0 : 1 ] + 'x' if impose_null == True : self . bootstrap_type = \"WCR\" + bootstrap_type_x else : self . bootstrap_type = \"WCU\" + bootstrap_type_x # not needed for all types, but compute anyways self . beta_hat = self . tXXinv @ self . tXy # precompute required objects for computing scores & vcov's if self . bootstrap_type in [ \"WCR3x\" ]: X = self . X X1 = X [:, self . R == 0 ] X1_list = [] tX1gX1g_list = [] tX1gyg_list = [] tXgX1g_list = [] tX1X1 = np . zeros (( self . k - 1 , self . k - 1 )) tX1y = np . zeros ( self . k - 1 ) for ix , g in enumerate ( self . bootclustid ): #ix = g = 1 X1_list . append ( X1 [ np . where ( self . bootcluster == g )]) tX1gX1g_list . append ( np . transpose ( X1_list [ ix ]) @ X1_list [ ix ]) tX1gyg_list . append ( np . transpose ( X1_list [ ix ]) @ self . Y_list [ ix ]) tXgX1g_list . append ( np . transpose ( self . X_list [ ix ]) @ X1_list [ ix ]) tX1X1 = tX1X1 + tX1gX1g_list [ ix ] tX1y = tX1y + tX1gyg_list [ ix ] beta_1g_tilde = [] for ix , g in enumerate ( self . bootclustid ): beta_1g_tilde . append ( np . linalg . pinv ( tX1X1 - tX1gX1g_list [ ix ]) @ ( tX1y - tX1gyg_list [ ix ])) beta = beta_1g_tilde M = tXgX1g_list elif self . bootstrap_type in [ \"WCU3x\" ]: beta_g_hat = [] for ix , g in enumerate ( self . bootclustid ): beta_g_hat . append ( np . linalg . pinv ( self . tXX - self . tXgXg_list [ ix ]) @ ( self . tXy - self . tXgyg_list [ ix ])) beta = beta_g_hat M = self . tXgXg_list elif self . bootstrap_type in [ \"WCR1x\" ]: A = 1 / ( np . transpose ( self . R ) @ self . tXXinv @ self . R ) beta_tilde = self . beta_hat - self . tXXinv @ self . R * A * ( self . R @ self . beta_hat - 0 ) beta = beta_tilde M = self . tXgXg_list elif self . bootstrap_type in [ \"WCU1x\" ]: beta = self . beta_hat M = self . tXgXg_list # compute scores based on tXgyg, M, beta scores_list = [] if ( self . bootstrap_type in [ \"WCR1x\" , \"WCU1x\" ]): for ix , g in enumerate ( self . bootclustid ): scores_list . append ( self . tXgyg_list [ ix ] - M [ ix ] @ beta ) elif ( self . bootstrap_type in [ \"WCR3x\" , \"WCU3x\" ]): for ix , g in enumerate ( self . bootclustid ): scores_list . append ( self . tXgyg_list [ ix ] - M [ ix ] @ beta [ ix ]) self . scores_mat = np . transpose ( np . array ( scores_list )) # k x G return self . scores_mat get_weights ( weights_type ) Function for getting weights for bootstrapping. Parameters: Name Type Description Default weights_type Tuple [ str , Callable ] The distribution to be used. Accepts Either 'rademacher', 'mammen', 'norm' or 'webb'. Optionally accepts a callable of one argument, n , the number of bootstraps iterations. required Returns: Type Description Tuple [ np . ndarray , int , bool ] Tuple[np.ndarray, int]: Returns the arrays of weights and the number of bootstrap iterations Source code in wildboottest\\wildboottest.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def get_weights ( self , weights_type : Union [ str , Callable ]) -> Tuple [ np . ndarray , int , bool ]: \"\"\"Function for getting weights for bootstrapping. Args: weights_type (Tuple[str, Callable]): The distribution to be used. Accepts Either 'rademacher', 'mammen', 'norm' or 'webb'. Optionally accepts a callable of one argument, `n`, the number of bootstraps iterations. Returns: Tuple[np.ndarray, int]: Returns the arrays of weights and the number of bootstrap iterations \"\"\" self . weights_type = weights_type if 2 ** self . N_G_bootcluster < self . B and weights_type == 'rademacher' : self . full_enumeration = True full_enumeration_warn = True else : self . full_enumeration = False full_enumeration_warn = False self . v , self . B = draw_weights ( t = self . weights_type , full_enumeration = self . full_enumeration , N_G_bootcluster = self . N_G_bootcluster , boot_iter = self . B ) return self . v , self . B , full_enumeration_warn","title":"WildBoottest"},{"location":"base/#wildboottest.wildboottest.Wildboottest--preliminaries-load-libraries-and-create-data","text":"import numpy as np from wildboottest.wildboottest import Wildboottest np.random.seed(12312312) N = 1000 k = 3 G = 10 X = np.random.normal(0, 1, N * k).reshape((N,k)) beta = np.random.normal(0,1,k) beta[0] = 0.005 u = np.random.normal(0,1,N) Y = 1 + X @ beta + u cluster = np.random.choice(list(range(0,G)), N) R = np.array([1, 0, 0]) B = 999","title":"preliminaries: load libraries and create data"},{"location":"base/#wildboottest.wildboottest.Wildboottest--run-the-wild-cluster-bootstrap","text":"wb = Wildboottest(X = X, Y = Y, cluster = cluster, R = R, B = B) wb.get_scores(bootstrap_type = \"11\", impose_null = True) wb.get_weights(weights_type= \"rademacher\") wb.get_numer() wb.get_denom() wb.get_tboot() wb.get_vcov() wb.get_tstat() wb.get_pvalue() Source code in wildboottest\\wildboottest.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 class Wildboottest : \"\"\" Create an object of Wildboottest and get p-value by successively applying methods in the following way: Example: >>> # preliminaries: load libraries and create data >>> import numpy as np >>> from wildboottest.wildboottest import Wildboottest >>> np.random.seed(12312312) >>> N = 1000 >>> k = 3 >>> G = 10 >>> X = np.random.normal(0, 1, N * k).reshape((N,k)) >>> beta = np.random.normal(0,1,k) >>> beta[0] = 0.005 >>> u = np.random.normal(0,1,N) >>> Y = 1 + X @ beta + u >>> cluster = np.random.choice(list(range(0,G)), N) >>> R = np.array([1, 0, 0]) >>> B = 999 >>> # run the wild cluster bootstrap >>> wb = Wildboottest(X = X, Y = Y, cluster = cluster, R = R, B = B) >>> wb.get_scores(bootstrap_type = \"11\", impose_null = True) >>> wb.get_weights(weights_type= \"rademacher\") >>> wb.get_numer() >>> wb.get_denom() >>> wb.get_tboot() >>> wb.get_vcov() >>> wb.get_tstat() >>> wb.get_pvalue() \"\"\" def __init__ ( self , X : Union [ np . ndarray , pd . DataFrame , pd . Series ], Y : Union [ np . ndarray , pd . DataFrame , pd . Series ], cluster : Union [ np . ndarray , pd . DataFrame , pd . Series ], R : Union [ np . ndarray , pd . DataFrame ], B : int , bootcluster : Union [ np . ndarray , pd . DataFrame , pd . Series , None ] = None , seed : Union [ int , None ] = None ) -> None : \"\"\"Initializes the Wild Cluster Bootstrap Class Args: X (Union[np.ndarray, pd.DataFrame, pd.Series]): Exogeneous variable array or dataframe Y (Union[np.ndarray, pd.DataFrame, pd.Series]): Endogenous variable array or dataframe cluster (Union[np.ndarray, pd.DataFrame, pd.Series]): Cluster array or dataframe R (Union[np.ndarray, pd.DataFrame]): Constraint matrix for running bootstrap B (int): bootstrap iterations bootcluster (Union[np.ndarray, pd.DataFrame, pd.Series, None], optional): Sub-cluster array. Defaults to None. seed (Union[int, None], optional): Random seed for random weight types. Defaults to None. Raises: TypeError: Raise if input arrays are lists TestMatrixNonConformabilityException: Raise if constraint matrix shape does not conform to X \"\"\" \"Initialize the wildboottest class\" #assert bootstrap_type in ['11', '13', '31', '33'] #assert impose_null in [True, False] if bootcluster is None : bootcluster = cluster for i in [ X , Y , cluster , bootcluster ]: if isinstance ( i , list ): raise TypeError ( f \" { i } cannot be a list\" ) if isinstance ( X , ( pd . DataFrame , pd . Series )): self . X = X . values else : self . X = X if isinstance ( Y , ( pd . DataFrame , pd . Series )): self . Y = Y . values else : self . Y = Y if isinstance ( cluster , pd . DataFrame ): self . clustid = cluster . unique () self . cluster = cluster . values if isinstance ( bootcluster , pd . DataFrame ): self . bootclustid = bootcluster . unique () self . bootcluster = bootcluster . values else : self . clustid = np . unique ( cluster ) self . bootclustid = np . unique ( bootcluster ) self . bootcluster = bootcluster if isinstance ( seed , int ): np . random . seed ( seed ) self . N_G_bootcluster = len ( self . bootclustid ) self . G = len ( self . clustid ) self . N = X . shape [ 0 ] self . k = X . shape [ 1 ] self . B = B self . R = R if self . X . shape [ 1 ] != self . R . shape [ 0 ]: raise TestMatrixNonConformabilityException ( \"The number of rows in the test matrix R, does not \" ) X_list = [] y_list = [] tXgXg_list = [] tXgyg_list = [] tXX = np . zeros (( self . k , self . k )) tXy = np . zeros ( self . k ) #all_cluster = np.unique(bootcluster) for g in self . bootclustid : # split X and Y by (boot)cluster X_g = self . X [ np . where ( self . bootcluster == g )] Y_g = self . Y [ np . where ( self . bootcluster == g )] tXgXg = np . transpose ( X_g ) @ X_g tXgyg = np . transpose ( X_g ) @ Y_g X_list . append ( X_g ) y_list . append ( Y_g ) tXgXg_list . append ( tXgXg ) tXgyg_list . append ( tXgyg ) tXX = tXX + tXgXg tXy = tXy + tXgyg self . X_list = X_list self . Y_list = y_list self . tXgXg_list = tXgXg_list self . tXgyg_list = tXgyg_list self . tXX = tXX self . tXy = tXy self . tXXinv = np . linalg . inv ( tXX ) self . RtXXinv = np . matmul ( R , self . tXXinv ) def get_weights ( self , weights_type : Union [ str , Callable ]) -> Tuple [ np . ndarray , int , bool ]: \"\"\"Function for getting weights for bootstrapping. Args: weights_type (Tuple[str, Callable]): The distribution to be used. Accepts Either 'rademacher', 'mammen', 'norm' or 'webb'. Optionally accepts a callable of one argument, `n`, the number of bootstraps iterations. Returns: Tuple[np.ndarray, int]: Returns the arrays of weights and the number of bootstrap iterations \"\"\" self . weights_type = weights_type if 2 ** self . N_G_bootcluster < self . B and weights_type == 'rademacher' : self . full_enumeration = True full_enumeration_warn = True else : self . full_enumeration = False full_enumeration_warn = False self . v , self . B = draw_weights ( t = self . weights_type , full_enumeration = self . full_enumeration , N_G_bootcluster = self . N_G_bootcluster , boot_iter = self . B ) return self . v , self . B , full_enumeration_warn def get_scores ( self , bootstrap_type : str , impose_null : bool , adj : bool = True , cluster_adj : bool = True ) -> np . ndarray : \"\"\"Run bootstrap and get scores for each variable Args: bootstrap_type (str): Determines which wild cluster bootstrap type should be run. Options are \"fnw11\",\"11\", \"13\", \"31\" and \"33\" for the wild cluster bootstrap and \"11\" and \"31\" for the heteroskedastic bootstrap. For more information, see the details section. \"fnw11\" is the default for the cluster bootstrap, which runs a \"11\" type wild cluster bootstrap via the algorithm outlined in \"fast and wild\" (Roodman et al (2019)). \"11\" is the default for the heteroskedastic bootstrap. impose_null (bool): Controls if the null hypothesis is imposed on the bootstrap dgp or not. Null imposed (WCR) by default. If False, the null is not imposed (WCU) adj (bool, optional): Whether to adjust for small sample. Defaults to True. cluster_adj (bool, optional): Whether to do a cluster-robust small sample correction. Defaults to True. Returns: np.ndarray: The output array of scores of shape kxG \"\"\" if bootstrap_type [ 1 : 2 ] == '1' : self . crv_type = \"crv1\" self . ssc = 1 if adj : self . ssc = self . ssc * ( self . N - 1 ) / ( self . N - self . k ) if cluster_adj : self . ssc = self . ssc * self . G / ( self . G - 1 ) elif bootstrap_type [ 1 : 2 ] == '3' : self . crv_type = \"crv3\" self . ssc = ( self . G - 1 ) / self . G bootstrap_type_x = bootstrap_type [ 0 : 1 ] + 'x' if impose_null == True : self . bootstrap_type = \"WCR\" + bootstrap_type_x else : self . bootstrap_type = \"WCU\" + bootstrap_type_x # not needed for all types, but compute anyways self . beta_hat = self . tXXinv @ self . tXy # precompute required objects for computing scores & vcov's if self . bootstrap_type in [ \"WCR3x\" ]: X = self . X X1 = X [:, self . R == 0 ] X1_list = [] tX1gX1g_list = [] tX1gyg_list = [] tXgX1g_list = [] tX1X1 = np . zeros (( self . k - 1 , self . k - 1 )) tX1y = np . zeros ( self . k - 1 ) for ix , g in enumerate ( self . bootclustid ): #ix = g = 1 X1_list . append ( X1 [ np . where ( self . bootcluster == g )]) tX1gX1g_list . append ( np . transpose ( X1_list [ ix ]) @ X1_list [ ix ]) tX1gyg_list . append ( np . transpose ( X1_list [ ix ]) @ self . Y_list [ ix ]) tXgX1g_list . append ( np . transpose ( self . X_list [ ix ]) @ X1_list [ ix ]) tX1X1 = tX1X1 + tX1gX1g_list [ ix ] tX1y = tX1y + tX1gyg_list [ ix ] beta_1g_tilde = [] for ix , g in enumerate ( self . bootclustid ): beta_1g_tilde . append ( np . linalg . pinv ( tX1X1 - tX1gX1g_list [ ix ]) @ ( tX1y - tX1gyg_list [ ix ])) beta = beta_1g_tilde M = tXgX1g_list elif self . bootstrap_type in [ \"WCU3x\" ]: beta_g_hat = [] for ix , g in enumerate ( self . bootclustid ): beta_g_hat . append ( np . linalg . pinv ( self . tXX - self . tXgXg_list [ ix ]) @ ( self . tXy - self . tXgyg_list [ ix ])) beta = beta_g_hat M = self . tXgXg_list elif self . bootstrap_type in [ \"WCR1x\" ]: A = 1 / ( np . transpose ( self . R ) @ self . tXXinv @ self . R ) beta_tilde = self . beta_hat - self . tXXinv @ self . R * A * ( self . R @ self . beta_hat - 0 ) beta = beta_tilde M = self . tXgXg_list elif self . bootstrap_type in [ \"WCU1x\" ]: beta = self . beta_hat M = self . tXgXg_list # compute scores based on tXgyg, M, beta scores_list = [] if ( self . bootstrap_type in [ \"WCR1x\" , \"WCU1x\" ]): for ix , g in enumerate ( self . bootclustid ): scores_list . append ( self . tXgyg_list [ ix ] - M [ ix ] @ beta ) elif ( self . bootstrap_type in [ \"WCR3x\" , \"WCU3x\" ]): for ix , g in enumerate ( self . bootclustid ): scores_list . append ( self . tXgyg_list [ ix ] - M [ ix ] @ beta [ ix ]) self . scores_mat = np . transpose ( np . array ( scores_list )) # k x G return self . scores_mat def get_numer ( self ): # Calculate the bootstrap numerator self . Cg = self . R @ self . tXXinv @ self . scores_mat self . numer = self . Cg @ self . v def get_denom ( self ): if self . crv_type == \"crv1\" : H = np . zeros (( self . G , self . G )) # numba optimization possible? for ixg , g in enumerate ( self . bootclustid ): for ixh , h in enumerate ( self . bootclustid ): # can be improved by replacing list calls with matrices; H [ ixg , ixh ] = self . R @ self . tXXinv @ self . tXgXg_list [ ixg ] @ self . tXXinv @ self . scores_mat [:, ixh ] # now compute denominator # numba / cython / c++ optimization possible? Porting this part from # R to c++ gives good speed improvements @jit def compute_denom ( Cg , H , bootclustid , B , G , v , ssc ): denom = np . zeros ( B + 1 ) for b in range ( 0 , B + 1 ): Zg = np . zeros ( G ) for ixg , g in enumerate ( bootclustid ): vH = 0 for ixh , h in enumerate ( bootclustid ): vH += v [ ixh , b ] * H [ ixg , ixh ] Zg [ ixg ] = Cg [ ixg ] * v [ ixg , b ] - vH # todo: ssc denom [ b ] = ssc * np . sum ( np . power ( Zg , 2 )) return denom self . denom = compute_denom ( self . Cg , H , self . bootclustid , self . B , self . G , self . v , self . ssc ) elif self . crv_type == \"crv3\" : self . inv_tXX_tXgXg = [] for ix , g in enumerate ( self . bootclustid ): self . inv_tXX_tXgXg . append ( np . linalg . pinv ( self . tXX - self . tXgXg_list [ ix ])) self . denom = np . zeros ( self . B + 1 ) for b in range ( 0 , self . B + 1 ): scores_g_boot = np . zeros (( self . G , self . k )) v_ = self . v [:, b ] for ixg , g in enumerate ( self . bootclustid ): scores_g_boot [ ixg ,:] = self . scores_mat [:, ixg ] * v_ [ ixg ] scores_boot = np . sum ( scores_g_boot , axis = 0 ) delta_b_star = self . tXXinv @ scores_boot delta_diff = np . zeros (( self . G , self . k )) for ixg , g in enumerate ( self . bootclustid ): score_diff = scores_boot - scores_g_boot [ ixg ,:] delta_diff [ ixg ,:] = ( ( self . inv_tXX_tXgXg [ ixg ] @ score_diff - delta_b_star ) ** 2 ) # se's self . denom [ b ] = self . ssc * np . sum ( delta_diff , axis = 0 )[ np . where ( self . R == 1 )] def get_tboot ( self ): t_boot = self . numer / np . sqrt ( self . denom ) self . t_boot = t_boot [ 1 :( self . B + 1 )] # drop first element - might be useful for comp. of def get_vcov ( self ): if self . crv_type == \"crv1\" : meat = np . zeros (( self . k , self . k )) for ixg , g in enumerate ( self . bootclustid ): score = np . transpose ( self . X_list [ ixg ]) @ ( self . Y_list [ ixg ] - self . X_list [ ixg ] @ self . beta_hat ) meat += np . outer ( score , score ) self . vcov = self . tXXinv @ meat @ self . tXXinv elif self . crv_type == \"crv3\" : # calculate leave-one out beta hat beta_jack = np . zeros (( self . G , self . k )) for ixg , g in enumerate ( self . bootclustid ): beta_jack [ ixg ,:] = ( np . linalg . pinv ( self . tXX - self . tXgXg_list [ ixg ]) @ ( self . tXy - np . transpose ( self . X_list [ ixg ]) @ self . Y_list [ ixg ]) ) if not hasattr ( self , \"beta_hat\" ): beta_hat = self . tXXinv @ self . tXy beta_center = self . beta_hat vcov3 = np . zeros (( self . k , self . k )) for ixg , g in enumerate ( self . bootclustid ): beta_centered = beta_jack [ ixg ,:] - beta_center vcov3 += np . outer ( beta_centered , beta_centered ) self . vcov = vcov3 def get_tstat ( self ): se = np . sqrt ( self . ssc * self . R @ self . vcov @ np . transpose ( self . R )) t_stats = self . beta_hat / se self . t_stat = t_stats [ np . where ( self . R == 1 )] def get_pvalue ( self , pval_type = \"two-tailed\" ): if pval_type == \"two-tailed\" : self . pvalue = np . mean ( np . abs ( self . t_stat ) < abs ( self . t_boot )) elif pval_type == \"equal-tailed\" : pl = np . mean ( self . t_stat < self . t_boot ) ph = np . mean ( self . t_stat > self . t_boot ) self . pvalue = 2 * min ( pl , ph ) elif pval_type == \">\" : self . pvalue = np . mean ( self . t_stat < self . t_boot ) else : self . pvalue = np . mean ( self . t_stat > self . t_boot )","title":"run the wild cluster bootstrap"},{"location":"base/#wildboottest.wildboottest.Wildboottest.__init__","text":"Initializes the Wild Cluster Bootstrap Class Parameters: Name Type Description Default X Union [ np . ndarray , pd . DataFrame , pd . Series ] Exogeneous variable array or dataframe required Y Union [ np . ndarray , pd . DataFrame , pd . Series ] Endogenous variable array or dataframe required cluster Union [ np . ndarray , pd . DataFrame , pd . Series ] Cluster array or dataframe required R Union [ np . ndarray , pd . DataFrame ] Constraint matrix for running bootstrap required B int bootstrap iterations required bootcluster Union [ np . ndarray , pd . DataFrame , pd . Series , None] Sub-cluster array. Defaults to None. None seed Union [ int , None] Random seed for random weight types. Defaults to None. None Raises: Type Description TypeError Raise if input arrays are lists TestMatrixNonConformabilityException Raise if constraint matrix shape does not conform to X Source code in wildboottest\\wildboottest.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def __init__ ( self , X : Union [ np . ndarray , pd . DataFrame , pd . Series ], Y : Union [ np . ndarray , pd . DataFrame , pd . Series ], cluster : Union [ np . ndarray , pd . DataFrame , pd . Series ], R : Union [ np . ndarray , pd . DataFrame ], B : int , bootcluster : Union [ np . ndarray , pd . DataFrame , pd . Series , None ] = None , seed : Union [ int , None ] = None ) -> None : \"\"\"Initializes the Wild Cluster Bootstrap Class Args: X (Union[np.ndarray, pd.DataFrame, pd.Series]): Exogeneous variable array or dataframe Y (Union[np.ndarray, pd.DataFrame, pd.Series]): Endogenous variable array or dataframe cluster (Union[np.ndarray, pd.DataFrame, pd.Series]): Cluster array or dataframe R (Union[np.ndarray, pd.DataFrame]): Constraint matrix for running bootstrap B (int): bootstrap iterations bootcluster (Union[np.ndarray, pd.DataFrame, pd.Series, None], optional): Sub-cluster array. Defaults to None. seed (Union[int, None], optional): Random seed for random weight types. Defaults to None. Raises: TypeError: Raise if input arrays are lists TestMatrixNonConformabilityException: Raise if constraint matrix shape does not conform to X \"\"\" \"Initialize the wildboottest class\" #assert bootstrap_type in ['11', '13', '31', '33'] #assert impose_null in [True, False] if bootcluster is None : bootcluster = cluster for i in [ X , Y , cluster , bootcluster ]: if isinstance ( i , list ): raise TypeError ( f \" { i } cannot be a list\" ) if isinstance ( X , ( pd . DataFrame , pd . Series )): self . X = X . values else : self . X = X if isinstance ( Y , ( pd . DataFrame , pd . Series )): self . Y = Y . values else : self . Y = Y if isinstance ( cluster , pd . DataFrame ): self . clustid = cluster . unique () self . cluster = cluster . values if isinstance ( bootcluster , pd . DataFrame ): self . bootclustid = bootcluster . unique () self . bootcluster = bootcluster . values else : self . clustid = np . unique ( cluster ) self . bootclustid = np . unique ( bootcluster ) self . bootcluster = bootcluster if isinstance ( seed , int ): np . random . seed ( seed ) self . N_G_bootcluster = len ( self . bootclustid ) self . G = len ( self . clustid ) self . N = X . shape [ 0 ] self . k = X . shape [ 1 ] self . B = B self . R = R if self . X . shape [ 1 ] != self . R . shape [ 0 ]: raise TestMatrixNonConformabilityException ( \"The number of rows in the test matrix R, does not \" ) X_list = [] y_list = [] tXgXg_list = [] tXgyg_list = [] tXX = np . zeros (( self . k , self . k )) tXy = np . zeros ( self . k ) #all_cluster = np.unique(bootcluster) for g in self . bootclustid : # split X and Y by (boot)cluster X_g = self . X [ np . where ( self . bootcluster == g )] Y_g = self . Y [ np . where ( self . bootcluster == g )] tXgXg = np . transpose ( X_g ) @ X_g tXgyg = np . transpose ( X_g ) @ Y_g X_list . append ( X_g ) y_list . append ( Y_g ) tXgXg_list . append ( tXgXg ) tXgyg_list . append ( tXgyg ) tXX = tXX + tXgXg tXy = tXy + tXgyg self . X_list = X_list self . Y_list = y_list self . tXgXg_list = tXgXg_list self . tXgyg_list = tXgyg_list self . tXX = tXX self . tXy = tXy self . tXXinv = np . linalg . inv ( tXX ) self . RtXXinv = np . matmul ( R , self . tXXinv )","title":"__init__()"},{"location":"base/#wildboottest.wildboottest.Wildboottest.get_scores","text":"Run bootstrap and get scores for each variable Parameters: Name Type Description Default bootstrap_type str Determines which wild cluster bootstrap type should be run. Options are \"fnw11\",\"11\", \"13\", \"31\" and \"33\" for the wild cluster bootstrap and \"11\" and \"31\" for the heteroskedastic bootstrap. For more information, see the details section. \"fnw11\" is the default for the cluster bootstrap, which runs a \"11\" type wild cluster bootstrap via the algorithm outlined in \"fast and wild\" (Roodman et al (2019)). \"11\" is the default for the heteroskedastic bootstrap. required impose_null bool Controls if the null hypothesis is imposed on the bootstrap dgp or not. Null imposed (WCR) by default. If False, the null is not imposed (WCU) required adj bool Whether to adjust for small sample. Defaults to True. True cluster_adj bool Whether to do a cluster-robust small sample correction. Defaults to True. True Returns: Type Description np . ndarray np.ndarray: The output array of scores of shape kxG Source code in wildboottest\\wildboottest.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 def get_scores ( self , bootstrap_type : str , impose_null : bool , adj : bool = True , cluster_adj : bool = True ) -> np . ndarray : \"\"\"Run bootstrap and get scores for each variable Args: bootstrap_type (str): Determines which wild cluster bootstrap type should be run. Options are \"fnw11\",\"11\", \"13\", \"31\" and \"33\" for the wild cluster bootstrap and \"11\" and \"31\" for the heteroskedastic bootstrap. For more information, see the details section. \"fnw11\" is the default for the cluster bootstrap, which runs a \"11\" type wild cluster bootstrap via the algorithm outlined in \"fast and wild\" (Roodman et al (2019)). \"11\" is the default for the heteroskedastic bootstrap. impose_null (bool): Controls if the null hypothesis is imposed on the bootstrap dgp or not. Null imposed (WCR) by default. If False, the null is not imposed (WCU) adj (bool, optional): Whether to adjust for small sample. Defaults to True. cluster_adj (bool, optional): Whether to do a cluster-robust small sample correction. Defaults to True. Returns: np.ndarray: The output array of scores of shape kxG \"\"\" if bootstrap_type [ 1 : 2 ] == '1' : self . crv_type = \"crv1\" self . ssc = 1 if adj : self . ssc = self . ssc * ( self . N - 1 ) / ( self . N - self . k ) if cluster_adj : self . ssc = self . ssc * self . G / ( self . G - 1 ) elif bootstrap_type [ 1 : 2 ] == '3' : self . crv_type = \"crv3\" self . ssc = ( self . G - 1 ) / self . G bootstrap_type_x = bootstrap_type [ 0 : 1 ] + 'x' if impose_null == True : self . bootstrap_type = \"WCR\" + bootstrap_type_x else : self . bootstrap_type = \"WCU\" + bootstrap_type_x # not needed for all types, but compute anyways self . beta_hat = self . tXXinv @ self . tXy # precompute required objects for computing scores & vcov's if self . bootstrap_type in [ \"WCR3x\" ]: X = self . X X1 = X [:, self . R == 0 ] X1_list = [] tX1gX1g_list = [] tX1gyg_list = [] tXgX1g_list = [] tX1X1 = np . zeros (( self . k - 1 , self . k - 1 )) tX1y = np . zeros ( self . k - 1 ) for ix , g in enumerate ( self . bootclustid ): #ix = g = 1 X1_list . append ( X1 [ np . where ( self . bootcluster == g )]) tX1gX1g_list . append ( np . transpose ( X1_list [ ix ]) @ X1_list [ ix ]) tX1gyg_list . append ( np . transpose ( X1_list [ ix ]) @ self . Y_list [ ix ]) tXgX1g_list . append ( np . transpose ( self . X_list [ ix ]) @ X1_list [ ix ]) tX1X1 = tX1X1 + tX1gX1g_list [ ix ] tX1y = tX1y + tX1gyg_list [ ix ] beta_1g_tilde = [] for ix , g in enumerate ( self . bootclustid ): beta_1g_tilde . append ( np . linalg . pinv ( tX1X1 - tX1gX1g_list [ ix ]) @ ( tX1y - tX1gyg_list [ ix ])) beta = beta_1g_tilde M = tXgX1g_list elif self . bootstrap_type in [ \"WCU3x\" ]: beta_g_hat = [] for ix , g in enumerate ( self . bootclustid ): beta_g_hat . append ( np . linalg . pinv ( self . tXX - self . tXgXg_list [ ix ]) @ ( self . tXy - self . tXgyg_list [ ix ])) beta = beta_g_hat M = self . tXgXg_list elif self . bootstrap_type in [ \"WCR1x\" ]: A = 1 / ( np . transpose ( self . R ) @ self . tXXinv @ self . R ) beta_tilde = self . beta_hat - self . tXXinv @ self . R * A * ( self . R @ self . beta_hat - 0 ) beta = beta_tilde M = self . tXgXg_list elif self . bootstrap_type in [ \"WCU1x\" ]: beta = self . beta_hat M = self . tXgXg_list # compute scores based on tXgyg, M, beta scores_list = [] if ( self . bootstrap_type in [ \"WCR1x\" , \"WCU1x\" ]): for ix , g in enumerate ( self . bootclustid ): scores_list . append ( self . tXgyg_list [ ix ] - M [ ix ] @ beta ) elif ( self . bootstrap_type in [ \"WCR3x\" , \"WCU3x\" ]): for ix , g in enumerate ( self . bootclustid ): scores_list . append ( self . tXgyg_list [ ix ] - M [ ix ] @ beta [ ix ]) self . scores_mat = np . transpose ( np . array ( scores_list )) # k x G return self . scores_mat","title":"get_scores()"},{"location":"base/#wildboottest.wildboottest.Wildboottest.get_weights","text":"Function for getting weights for bootstrapping. Parameters: Name Type Description Default weights_type Tuple [ str , Callable ] The distribution to be used. Accepts Either 'rademacher', 'mammen', 'norm' or 'webb'. Optionally accepts a callable of one argument, n , the number of bootstraps iterations. required Returns: Type Description Tuple [ np . ndarray , int , bool ] Tuple[np.ndarray, int]: Returns the arrays of weights and the number of bootstrap iterations Source code in wildboottest\\wildboottest.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def get_weights ( self , weights_type : Union [ str , Callable ]) -> Tuple [ np . ndarray , int , bool ]: \"\"\"Function for getting weights for bootstrapping. Args: weights_type (Tuple[str, Callable]): The distribution to be used. Accepts Either 'rademacher', 'mammen', 'norm' or 'webb'. Optionally accepts a callable of one argument, `n`, the number of bootstraps iterations. Returns: Tuple[np.ndarray, int]: Returns the arrays of weights and the number of bootstrap iterations \"\"\" self . weights_type = weights_type if 2 ** self . N_G_bootcluster < self . B and weights_type == 'rademacher' : self . full_enumeration = True full_enumeration_warn = True else : self . full_enumeration = False full_enumeration_warn = False self . v , self . B = draw_weights ( t = self . weights_type , full_enumeration = self . full_enumeration , N_G_bootcluster = self . N_G_bootcluster , boot_iter = self . B ) return self . v , self . B , full_enumeration_warn","title":"get_weights()"},{"location":"library_apis/","text":"Library APIs Statsmodels Run a wild cluster bootstrap based on an object of class 'statsmodels.regression.linear_model.OLS' Parameters: Name Type Description Default model OLS A statsmodels regression object required cluster Union [ np . ndarray , pd . Series , pd . DataFrame ] A numpy array of dimension one, containing the clustering variable. required B int The number of bootstrap iterations to run required param Union [ str , None] A string of length one, containing the test parameter of interest. Defaults to None. None weights_type str The type of bootstrap weights. Either 'rademacher', 'mammen', 'webb' or 'normal'. 'rademacher' by default. Defaults to 'rademacher'. 'rademacher' impose_null bool Should the null hypothesis be imposed on the bootstrap dgp, or not? Defaults to True. True bootstrap_type str A string of length one. Allows to choose the bootstrap type to be run. Either '11', '31', '13' or '33'. '11' by default. Defaults to '11'. '11' seed Union [ str , None] Option to provide a random seed. Defaults to None. None Raises: Type Description Exception Raises if param is not a string Returns: Type Description pd . DataFrame pd.DataFrame: A wild cluster bootstrapped p-value(s). pd . DataFrame Example: >>> from wildboottest.wildboottest import wildboottest >>> import statsmodels.api as sm >>> import numpy as np >>> import pandas as pd >>> np.random.seed(12312312) >>> N = 1000 >>> k = 10 >>> G = 10 >>> X = np.random.normal(0, 1, N * k).reshape((N,k)) >>> X = pd.DataFrame(X) >>> X.rename(columns = {0:\"X1\"}, inplace = True) >>> beta = np.random.normal(0,1,k) >>> beta[0] = 0.005 >>> u = np.random.normal(0,1,N) >>> Y = 1 + X @ beta + u >>> cluster = np.random.choice(list(range(0,G)), N) >>> model = sm.OLS(Y, X) >>> wildboottest(model, param = \"X1\", cluster = cluster, B = 9999) >>> wildboottest(model, cluster = cluster, B = 9999) Source code in wildboottest\\wildboottest.py 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 def wildboottest ( model : 'OLS' , cluster : Union [ np . ndarray , pd . Series , pd . DataFrame ], B : int , param : Union [ str , None ] = None , weights_type : str = 'rademacher' , impose_null : bool = True , bootstrap_type : str = '11' , seed : Union [ str , None ] = None , adj : bool = True , cluster_adj : bool = True , show = True ) -> pd . DataFrame : \"\"\"Run a wild cluster bootstrap based on an object of class 'statsmodels.regression.linear_model.OLS' Args: model (OLS): A statsmodels regression object cluster (Union[np.ndarray, pd.Series, pd.DataFrame]): A numpy array of dimension one, containing the clustering variable. B (int): The number of bootstrap iterations to run param (Union[str, None], optional): A string of length one, containing the test parameter of interest. Defaults to None. weights_type (str, optional): The type of bootstrap weights. Either 'rademacher', 'mammen', 'webb' or 'normal'. 'rademacher' by default. Defaults to 'rademacher'. impose_null (bool, optional): Should the null hypothesis be imposed on the bootstrap dgp, or not? Defaults to True. bootstrap_type (str, optional):A string of length one. Allows to choose the bootstrap type to be run. Either '11', '31', '13' or '33'. '11' by default. Defaults to '11'. seed (Union[str, None], optional): Option to provide a random seed. Defaults to None. Raises: Exception: Raises if `param` is not a string Returns: pd.DataFrame: A wild cluster bootstrapped p-value(s). Example: >>> from wildboottest.wildboottest import wildboottest >>> import statsmodels.api as sm >>> import numpy as np >>> import pandas as pd >>> np.random.seed(12312312) >>> N = 1000 >>> k = 10 >>> G = 10 >>> X = np.random.normal(0, 1, N * k).reshape((N,k)) >>> X = pd.DataFrame(X) >>> X.rename(columns = {0:\"X1\"}, inplace = True) >>> beta = np.random.normal(0,1,k) >>> beta[0] = 0.005 >>> u = np.random.normal(0,1,N) >>> Y = 1 + X @ beta + u >>> cluster = np.random.choice(list(range(0,G)), N) >>> model = sm.OLS(Y, X) >>> wildboottest(model, param = \"X1\", cluster = cluster, B = 9999) >>> wildboottest(model, cluster = cluster, B = 9999) \"\"\" # does model.exog already exclude missing values? X = model . exog # interestingly, the dependent variable is called 'endogeneous' Y = model . endog # weights not yet used, only as a placeholder weights = model . weights xnames = model . data . xnames ynames = model . data . ynames pvalues = [] tstats = [] def generate_stats ( param ): R = np . zeros ( len ( xnames )) R [ xnames . index ( param )] = 1 # Just test for beta=0 # is it possible to fetch the clustering variables from the pre-processed data # frame, e.g. with 'excluding' observations with missings etc # cluster = ... boot = Wildboottest ( X = X , Y = Y , cluster = cluster , R = R , B = B , seed = seed ) boot . get_scores ( bootstrap_type = bootstrap_type , impose_null = impose_null , adj = adj , cluster_adj = cluster_adj ) _ , _ , full_enumeration_warn = boot . get_weights ( weights_type = weights_type ) boot . get_numer () boot . get_denom () boot . get_tboot () boot . get_vcov () boot . get_tstat () boot . get_pvalue ( pval_type = \"two-tailed\" ) pvalues . append ( boot . pvalue ) tstats . append ( boot . t_stat [ 0 ]) return pvalues , tstats , full_enumeration_warn if param is None : for x in xnames : pvalues , tstats , full_enumeration_warn = generate_stats ( x ) param = xnames elif isinstance ( param , str ): pvalues , tstats , full_enumeration_warn = generate_stats ( param ) else : raise Exception ( \"`param` not correctly specified\" ) if full_enumeration_warn : warnings . warn ( \"2^G < the number of boot iterations, setting full_enumeration to True.\" ) res = { 'param' : param , 'statistic' : tstats , 'p-value' : pvalues } res_df = pd . DataFrame ( res ) . set_index ( 'param' ) if show : print ( res_df . to_markdown ( floatfmt = \".3f\" )) return res_df","title":"Library APIs"},{"location":"library_apis/#library-apis","text":"","title":"Library APIs"},{"location":"library_apis/#statsmodels","text":"Run a wild cluster bootstrap based on an object of class 'statsmodels.regression.linear_model.OLS' Parameters: Name Type Description Default model OLS A statsmodels regression object required cluster Union [ np . ndarray , pd . Series , pd . DataFrame ] A numpy array of dimension one, containing the clustering variable. required B int The number of bootstrap iterations to run required param Union [ str , None] A string of length one, containing the test parameter of interest. Defaults to None. None weights_type str The type of bootstrap weights. Either 'rademacher', 'mammen', 'webb' or 'normal'. 'rademacher' by default. Defaults to 'rademacher'. 'rademacher' impose_null bool Should the null hypothesis be imposed on the bootstrap dgp, or not? Defaults to True. True bootstrap_type str A string of length one. Allows to choose the bootstrap type to be run. Either '11', '31', '13' or '33'. '11' by default. Defaults to '11'. '11' seed Union [ str , None] Option to provide a random seed. Defaults to None. None Raises: Type Description Exception Raises if param is not a string Returns: Type Description pd . DataFrame pd.DataFrame: A wild cluster bootstrapped p-value(s). pd . DataFrame Example: >>> from wildboottest.wildboottest import wildboottest >>> import statsmodels.api as sm >>> import numpy as np >>> import pandas as pd >>> np.random.seed(12312312) >>> N = 1000 >>> k = 10 >>> G = 10 >>> X = np.random.normal(0, 1, N * k).reshape((N,k)) >>> X = pd.DataFrame(X) >>> X.rename(columns = {0:\"X1\"}, inplace = True) >>> beta = np.random.normal(0,1,k) >>> beta[0] = 0.005 >>> u = np.random.normal(0,1,N) >>> Y = 1 + X @ beta + u >>> cluster = np.random.choice(list(range(0,G)), N) >>> model = sm.OLS(Y, X) >>> wildboottest(model, param = \"X1\", cluster = cluster, B = 9999) >>> wildboottest(model, cluster = cluster, B = 9999) Source code in wildboottest\\wildboottest.py 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 def wildboottest ( model : 'OLS' , cluster : Union [ np . ndarray , pd . Series , pd . DataFrame ], B : int , param : Union [ str , None ] = None , weights_type : str = 'rademacher' , impose_null : bool = True , bootstrap_type : str = '11' , seed : Union [ str , None ] = None , adj : bool = True , cluster_adj : bool = True , show = True ) -> pd . DataFrame : \"\"\"Run a wild cluster bootstrap based on an object of class 'statsmodels.regression.linear_model.OLS' Args: model (OLS): A statsmodels regression object cluster (Union[np.ndarray, pd.Series, pd.DataFrame]): A numpy array of dimension one, containing the clustering variable. B (int): The number of bootstrap iterations to run param (Union[str, None], optional): A string of length one, containing the test parameter of interest. Defaults to None. weights_type (str, optional): The type of bootstrap weights. Either 'rademacher', 'mammen', 'webb' or 'normal'. 'rademacher' by default. Defaults to 'rademacher'. impose_null (bool, optional): Should the null hypothesis be imposed on the bootstrap dgp, or not? Defaults to True. bootstrap_type (str, optional):A string of length one. Allows to choose the bootstrap type to be run. Either '11', '31', '13' or '33'. '11' by default. Defaults to '11'. seed (Union[str, None], optional): Option to provide a random seed. Defaults to None. Raises: Exception: Raises if `param` is not a string Returns: pd.DataFrame: A wild cluster bootstrapped p-value(s). Example: >>> from wildboottest.wildboottest import wildboottest >>> import statsmodels.api as sm >>> import numpy as np >>> import pandas as pd >>> np.random.seed(12312312) >>> N = 1000 >>> k = 10 >>> G = 10 >>> X = np.random.normal(0, 1, N * k).reshape((N,k)) >>> X = pd.DataFrame(X) >>> X.rename(columns = {0:\"X1\"}, inplace = True) >>> beta = np.random.normal(0,1,k) >>> beta[0] = 0.005 >>> u = np.random.normal(0,1,N) >>> Y = 1 + X @ beta + u >>> cluster = np.random.choice(list(range(0,G)), N) >>> model = sm.OLS(Y, X) >>> wildboottest(model, param = \"X1\", cluster = cluster, B = 9999) >>> wildboottest(model, cluster = cluster, B = 9999) \"\"\" # does model.exog already exclude missing values? X = model . exog # interestingly, the dependent variable is called 'endogeneous' Y = model . endog # weights not yet used, only as a placeholder weights = model . weights xnames = model . data . xnames ynames = model . data . ynames pvalues = [] tstats = [] def generate_stats ( param ): R = np . zeros ( len ( xnames )) R [ xnames . index ( param )] = 1 # Just test for beta=0 # is it possible to fetch the clustering variables from the pre-processed data # frame, e.g. with 'excluding' observations with missings etc # cluster = ... boot = Wildboottest ( X = X , Y = Y , cluster = cluster , R = R , B = B , seed = seed ) boot . get_scores ( bootstrap_type = bootstrap_type , impose_null = impose_null , adj = adj , cluster_adj = cluster_adj ) _ , _ , full_enumeration_warn = boot . get_weights ( weights_type = weights_type ) boot . get_numer () boot . get_denom () boot . get_tboot () boot . get_vcov () boot . get_tstat () boot . get_pvalue ( pval_type = \"two-tailed\" ) pvalues . append ( boot . pvalue ) tstats . append ( boot . t_stat [ 0 ]) return pvalues , tstats , full_enumeration_warn if param is None : for x in xnames : pvalues , tstats , full_enumeration_warn = generate_stats ( x ) param = xnames elif isinstance ( param , str ): pvalues , tstats , full_enumeration_warn = generate_stats ( param ) else : raise Exception ( \"`param` not correctly specified\" ) if full_enumeration_warn : warnings . warn ( \"2^G < the number of boot iterations, setting full_enumeration to True.\" ) res = { 'param' : param , 'statistic' : tstats , 'p-value' : pvalues } res_df = pd . DataFrame ( res ) . set_index ( 'param' ) if show : print ( res_df . to_markdown ( floatfmt = \".3f\" )) return res_df","title":"Statsmodels"},{"location":"weights/","text":"Weights draw_weights ( t , full_enumeration , N_G_bootcluster , boot_iter ) draw bootstrap weights Parameters: Name Type Description Default t str | callable the type of the weights distribution. Either 'rademacher', 'mammen', 'norm' or 'webb' required full_enumeration bool should deterministic full enumeration be employed required N_G_bootcluster int the number of bootstrap clusters required boot_iter int the number of bootstrap iterations required Returns: Type Description Tuple [ np . ndarray , int ] Tuple[np.ndarray, int]: a matrix of dimension N_G_bootcluster x (boot_iter + 1) and the number of iterations Source code in wildboottest\\weights.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def draw_weights ( t : Union [ str , Callable ], full_enumeration : bool , N_G_bootcluster : int , boot_iter : int ) -> Tuple [ np . ndarray , int ]: \"\"\"draw bootstrap weights Args: t (str|callable): the type of the weights distribution. Either 'rademacher', 'mammen', 'norm' or 'webb' If `t` is a callable, must be a function of one variable, `n`, and return a vector of size `n` full_enumeration (bool): should deterministic full enumeration be employed N_G_bootcluster (int): the number of bootstrap clusters boot_iter (int): the number of bootstrap iterations Returns: Tuple[np.ndarray, int]: a matrix of dimension N_G_bootcluster x (boot_iter + 1) and the number of iterations \"\"\" #TODO: we can use the `case` feature in python, but that's only available in 3.10+ will do a 3.7 version for now # Will take out this and make separate functions for readability if isinstance ( t , str ): wild_draw_fun = wild_draw_fun_dict . get ( t ) if wild_draw_fun is None : raise WildDrawFunctionException ( \"Function type specified is not supported or there is a typo.\" ) elif callable ( t ): wild_draw_fun = t elif t is None : raise WildDrawFunctionException ( \"`t` must be specified\" ) else : raise ValueError ( f \"t can be string or callable, but got { type ( t ) } \" ) # do full enumeration for rademacher weights if bootstrap iterations # B exceed number of possible permutations else random sampling # full_enumeration only for rademacher weights (set earlier) if full_enumeration : t = 0 # what is this needed for? # with N_G_bootcluster draws, get all combinations of [-1,1] WITH # replacement, in matrix form v0 = np . transpose ( np . array ( list ( product ([ - 1 , 1 ], repeat = N_G_bootcluster )))) else : # else: just draw with replacement - by chance, some permutations # might occur more than once v0 = wild_draw_fun ( n = N_G_bootcluster * boot_iter ) v0 = v0 . reshape ( N_G_bootcluster , boot_iter ) # weights matrix # update boot_iter (B) - only relevant in enumeration case boot_iter = v0 . shape [ 1 ] v = np . insert ( v0 , 0 , 1 , axis = 1 ) return v , boot_iter","title":"Weighting"},{"location":"weights/#weights","text":"","title":"Weights"},{"location":"weights/#wildboottest.weights.draw_weights","text":"draw bootstrap weights Parameters: Name Type Description Default t str | callable the type of the weights distribution. Either 'rademacher', 'mammen', 'norm' or 'webb' required full_enumeration bool should deterministic full enumeration be employed required N_G_bootcluster int the number of bootstrap clusters required boot_iter int the number of bootstrap iterations required Returns: Type Description Tuple [ np . ndarray , int ] Tuple[np.ndarray, int]: a matrix of dimension N_G_bootcluster x (boot_iter + 1) and the number of iterations Source code in wildboottest\\weights.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def draw_weights ( t : Union [ str , Callable ], full_enumeration : bool , N_G_bootcluster : int , boot_iter : int ) -> Tuple [ np . ndarray , int ]: \"\"\"draw bootstrap weights Args: t (str|callable): the type of the weights distribution. Either 'rademacher', 'mammen', 'norm' or 'webb' If `t` is a callable, must be a function of one variable, `n`, and return a vector of size `n` full_enumeration (bool): should deterministic full enumeration be employed N_G_bootcluster (int): the number of bootstrap clusters boot_iter (int): the number of bootstrap iterations Returns: Tuple[np.ndarray, int]: a matrix of dimension N_G_bootcluster x (boot_iter + 1) and the number of iterations \"\"\" #TODO: we can use the `case` feature in python, but that's only available in 3.10+ will do a 3.7 version for now # Will take out this and make separate functions for readability if isinstance ( t , str ): wild_draw_fun = wild_draw_fun_dict . get ( t ) if wild_draw_fun is None : raise WildDrawFunctionException ( \"Function type specified is not supported or there is a typo.\" ) elif callable ( t ): wild_draw_fun = t elif t is None : raise WildDrawFunctionException ( \"`t` must be specified\" ) else : raise ValueError ( f \"t can be string or callable, but got { type ( t ) } \" ) # do full enumeration for rademacher weights if bootstrap iterations # B exceed number of possible permutations else random sampling # full_enumeration only for rademacher weights (set earlier) if full_enumeration : t = 0 # what is this needed for? # with N_G_bootcluster draws, get all combinations of [-1,1] WITH # replacement, in matrix form v0 = np . transpose ( np . array ( list ( product ([ - 1 , 1 ], repeat = N_G_bootcluster )))) else : # else: just draw with replacement - by chance, some permutations # might occur more than once v0 = wild_draw_fun ( n = N_G_bootcluster * boot_iter ) v0 = v0 . reshape ( N_G_bootcluster , boot_iter ) # weights matrix # update boot_iter (B) - only relevant in enumeration case boot_iter = v0 . shape [ 1 ] v = np . insert ( v0 , 0 , 1 , axis = 1 ) return v , boot_iter","title":"draw_weights()"}]}