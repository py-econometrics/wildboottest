{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Wildboottest wildboottest implements multiple fast wild cluster bootstrap algorithms as developed in Roodman et al (2019) and MacKinnon, Nielsen & Webb (2022) . Functionality It has similar, but more limited functionality than Stata's boottest , R's fwildcusterboot or Julia's WildBootTests.jl . It supports The wild cluster bootstrap for OLS ( Cameron, Gelbach & Miller 2008 , Roodman et al (2019) ). Multiple new versions of the wild cluster bootstrap as described in MacKinnon, Nielsen & Webb (2022) , including the WCR13, WCR31, WCR33, WCU13, WCU31 and WCU33. CRV1 and CRV3 robust variance estimation, including the CRV3-Jackknife as described in MacKinnon, Nielsen & Webb (2022) . At the moment, wildboottest only computes wild cluster bootstrapped p-values , and no confidence intervals. Other features that are currently not supported: The (non-clustered) wild bootstrap for OLS ( Wu, 1986 ). The subcluster bootstrap ( MacKinnon and Webb 2018 ). Confidence intervals formed by inverting the test and iteratively searching for bounds. Multiway clustering. Direct support for statsmodels and linearmodels is work in progress. If you'd like to cooperate, either send us an email or comment in the issues section! Installation You can install wildboottest from PyPi by running pip install wildboottest Citation If you use wildboottest in your research, please consider citing it via @Unpublished{wildboottest2022, Title = {Fast Wild Cluster Bootstrap Inference in Python via wildboottest}, Author = {Alexander Fischer and Aleksandr Michuda}, Year = {2022}, Url = {https://github.com/s3alfisc/wildboottest} }","title":"Home"},{"location":"#welcome-to-wildboottest","text":"wildboottest implements multiple fast wild cluster bootstrap algorithms as developed in Roodman et al (2019) and MacKinnon, Nielsen & Webb (2022) .","title":"Welcome to Wildboottest"},{"location":"#functionality","text":"It has similar, but more limited functionality than Stata's boottest , R's fwildcusterboot or Julia's WildBootTests.jl . It supports The wild cluster bootstrap for OLS ( Cameron, Gelbach & Miller 2008 , Roodman et al (2019) ). Multiple new versions of the wild cluster bootstrap as described in MacKinnon, Nielsen & Webb (2022) , including the WCR13, WCR31, WCR33, WCU13, WCU31 and WCU33. CRV1 and CRV3 robust variance estimation, including the CRV3-Jackknife as described in MacKinnon, Nielsen & Webb (2022) . At the moment, wildboottest only computes wild cluster bootstrapped p-values , and no confidence intervals. Other features that are currently not supported: The (non-clustered) wild bootstrap for OLS ( Wu, 1986 ). The subcluster bootstrap ( MacKinnon and Webb 2018 ). Confidence intervals formed by inverting the test and iteratively searching for bounds. Multiway clustering. Direct support for statsmodels and linearmodels is work in progress. If you'd like to cooperate, either send us an email or comment in the issues section!","title":"Functionality"},{"location":"#installation","text":"You can install wildboottest from PyPi by running pip install wildboottest","title":"Installation"},{"location":"#citation","text":"If you use wildboottest in your research, please consider citing it via @Unpublished{wildboottest2022, Title = {Fast Wild Cluster Bootstrap Inference in Python via wildboottest}, Author = {Alexander Fischer and Aleksandr Michuda}, Year = {2022}, Url = {https://github.com/s3alfisc/wildboottest} }","title":"Citation"},{"location":"base/","text":"Create an object of WildboottestCL and get p-value by successively applying methods in the following way: Example preliminaries: load libraries and create data import numpy as np from wildboottest.wildboottest import WildboottestCL np.random.seed(12312312) N = 1000 k = 3 G = 10 X = np.random.normal(0, 1, N * k).reshape((N,k)) beta = np.random.normal(0,1,k) beta[0] = 0.005 u = np.random.normal(0,1,N) Y = 1 + X @ beta + u cluster = np.random.choice(list(range(0,G)), N) R = np.array([1, 0, 0]) B = 999 run the wild cluster bootstrap wb = WildboottestCL(X = X, Y = Y, cluster = cluster, R = R, B = B) wb.get_scores(bootstrap_type = \"11\", impose_null = True) wb.get_weights(weights_type= \"rademacher\") wb.get_numer() wb.get_denom() wb.get_tboot() wb.get_vcov() wb.get_tstat() wb.get_pvalue() Source code in wildboottest\\wildboottest.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 class WildboottestCL : \"\"\" Create an object of WildboottestCL and get p-value by successively applying methods in the following way: Example: >>> # preliminaries: load libraries and create data >>> import numpy as np >>> from wildboottest.wildboottest import WildboottestCL >>> np.random.seed(12312312) >>> N = 1000 >>> k = 3 >>> G = 10 >>> X = np.random.normal(0, 1, N * k).reshape((N,k)) >>> beta = np.random.normal(0,1,k) >>> beta[0] = 0.005 >>> u = np.random.normal(0,1,N) >>> Y = 1 + X @ beta + u >>> cluster = np.random.choice(list(range(0,G)), N) >>> R = np.array([1, 0, 0]) >>> B = 999 >>> # run the wild cluster bootstrap >>> wb = WildboottestCL(X = X, Y = Y, cluster = cluster, R = R, B = B) >>> wb.get_scores(bootstrap_type = \"11\", impose_null = True) >>> wb.get_weights(weights_type= \"rademacher\") >>> wb.get_numer() >>> wb.get_denom() >>> wb.get_tboot() >>> wb.get_vcov() >>> wb.get_tstat() >>> wb.get_pvalue() \"\"\" def __init__ ( self , X : Union [ np . ndarray , pd . DataFrame , pd . Series ], Y : Union [ np . ndarray , pd . DataFrame , pd . Series ], cluster : Union [ np . ndarray , pd . DataFrame , pd . Series ], R : Union [ np . ndarray , pd . DataFrame ], B : int , bootcluster : Union [ np . ndarray , pd . DataFrame , pd . Series , None ] = None , seed : Union [ int , None ] = None ) -> None : \"\"\"Initializes the Wild Cluster Bootstrap Class Args: X (Union[np.ndarray, pd.DataFrame, pd.Series]): Exogeneous variable array or dataframe Y (Union[np.ndarray, pd.DataFrame, pd.Series]): Endogenous variable array or dataframe cluster (Union[np.ndarray, pd.DataFrame, pd.Series]): Cluster array or dataframe R (Union[np.ndarray, pd.DataFrame]): Constraint matrix for running bootstrap B (int): bootstrap iterations bootcluster (Union[np.ndarray, pd.DataFrame, pd.Series, None], optional): Sub-cluster array. Defaults to None. seed (Union[int, None], optional): Random seed for random weight types. Defaults to None. Raises: TypeError: Raise if input arrays are lists TestMatrixNonConformabilityException: Raise if constraint matrix shape does not conform to X \"\"\" \"Initialize the WildboottestCL class\" #assert bootstrap_type in ['11', '13', '31', '33'] #assert impose_null in [True, False] if bootcluster is None : bootcluster = cluster for i in [ X , Y , cluster , bootcluster ]: if isinstance ( i , list ): raise TypeError ( f \" { i } cannot be a list\" ) if isinstance ( X , ( pd . DataFrame , pd . Series )): self . X = X . values else : self . X = X if isinstance ( Y , ( pd . DataFrame , pd . Series )): self . Y = Y . values else : self . Y = Y if isinstance ( cluster , pd . DataFrame ): self . clustid = cluster . unique () self . cluster = cluster . values if isinstance ( bootcluster , pd . DataFrame ): self . bootclustid = bootcluster . unique () self . bootcluster = bootcluster . values else : self . clustid = np . unique ( cluster ) self . bootclustid = np . unique ( bootcluster ) self . bootcluster = bootcluster if isinstance ( seed , int ): np . random . seed ( seed ) self . N_G_bootcluster = len ( self . bootclustid ) self . G = len ( self . clustid ) self . N = X . shape [ 0 ] self . k = X . shape [ 1 ] self . B = B self . R = R if self . X . shape [ 1 ] != self . R . shape [ 0 ]: raise TestMatrixNonConformabilityException ( \"The number of rows in the test matrix R, does not \" ) X_list = [] y_list = [] tXgXg_list = [] tXgyg_list = [] tXX = np . zeros (( self . k , self . k )) tXy = np . zeros ( self . k ) #all_cluster = np.unique(bootcluster) for g in self . bootclustid : # split X and Y by (boot)cluster X_g = self . X [ np . where ( self . bootcluster == g )] Y_g = self . Y [ np . where ( self . bootcluster == g )] tXgXg = np . transpose ( X_g ) @ X_g tXgyg = np . transpose ( X_g ) @ Y_g X_list . append ( X_g ) y_list . append ( Y_g ) tXgXg_list . append ( tXgXg ) tXgyg_list . append ( tXgyg ) tXX += tXgXg tXy += tXgyg self . X_list = X_list self . Y_list = y_list self . tXgXg_list = tXgXg_list self . tXgyg_list = tXgyg_list self . tXX = tXX self . tXy = tXy self . tXXinv = np . linalg . inv ( tXX ) self . RtXXinv = np . matmul ( R , self . tXXinv ) def get_weights ( self , weights_type : Union [ str , Callable ]) -> Tuple [ np . ndarray , int , bool ]: \"\"\"Function for getting weights for bootstrapping. Args: weights_type (Tuple[str, Callable]): The distribution to be used. Accepts Either 'rademacher', 'mammen', 'norm' or 'webb'. Optionally accepts a callable of one argument, `n`, the number of bootstraps iterations. Returns: Tuple[np.ndarray, int]: Returns the arrays of weights and the number of bootstrap iterations \"\"\" self . weights_type = weights_type if 2 ** self . N_G_bootcluster < self . B and weights_type == 'rademacher' : self . full_enumeration = True full_enumeration_warn = True else : self . full_enumeration = False full_enumeration_warn = False self . v , self . B = draw_weights ( t = self . weights_type , full_enumeration = self . full_enumeration , N_G_bootcluster = self . N_G_bootcluster , boot_iter = self . B ) return self . v , self . B , full_enumeration_warn def get_scores ( self , bootstrap_type : str , impose_null : bool , adj : bool = True , cluster_adj : bool = True ) -> np . ndarray : \"\"\"Run bootstrap and get scores for each variable Args: bootstrap_type (str): Determines which wild cluster bootstrap type should be run. Options are \"fnw11\",\"11\", \"13\", \"31\" and \"33\" for the wild cluster bootstrap and \"11\" and \"31\" for the heteroskedastic bootstrap. For more information, see the details section. \"fnw11\" is the default for the cluster bootstrap, which runs a \"11\" type wild cluster bootstrap via the algorithm outlined in \"fast and wild\" (Roodman et al (2019)). \"11\" is the default for the heteroskedastic bootstrap. impose_null (bool): Controls if the null hypothesis is imposed on the bootstrap dgp or not. Null imposed (WCR) by default. If False, the null is not imposed (WCU) adj (bool, optional): Whether to adjust for small sample. Defaults to True. cluster_adj (bool, optional): Whether to do a cluster-robust small sample correction. Defaults to True. Returns: np.ndarray: The output array of scores of shape kxG \"\"\" if bootstrap_type [ 1 : 2 ] == '1' : self . crv_type = \"crv1\" self . ssc = 1 if adj : self . ssc = self . ssc * ( self . N - 1 ) / ( self . N - self . k ) if cluster_adj : self . ssc = self . ssc * self . G / ( self . G - 1 ) elif bootstrap_type [ 1 : 2 ] == '3' : self . crv_type = \"crv3\" self . ssc = ( self . G - 1 ) / self . G bootstrap_type_x = bootstrap_type [ 0 : 1 ] + 'x' if impose_null == True : self . bootstrap_type = \"WCR\" + bootstrap_type_x else : self . bootstrap_type = \"WCU\" + bootstrap_type_x # not needed for all types, but compute anyways self . beta_hat = self . tXXinv @ self . tXy # precompute required objects for computing scores & vcov's if self . bootstrap_type in [ \"WCR3x\" ]: X = self . X X1 = X [:, self . R == 0 ] X1_list = [] tX1gX1g_list = [] tX1gyg_list = [] tXgX1g_list = [] tX1X1 = np . zeros (( self . k - 1 , self . k - 1 )) tX1y = np . zeros ( self . k - 1 ) for ix , g in enumerate ( self . bootclustid ): #ix = g = 1 X1_list . append ( X1 [ np . where ( self . bootcluster == g )]) tX1gX1g_list . append ( np . transpose ( X1_list [ ix ]) @ X1_list [ ix ]) tX1gyg_list . append ( np . transpose ( X1_list [ ix ]) @ self . Y_list [ ix ]) tXgX1g_list . append ( np . transpose ( self . X_list [ ix ]) @ X1_list [ ix ]) tX1X1 = tX1X1 + tX1gX1g_list [ ix ] tX1y = tX1y + tX1gyg_list [ ix ] beta_1g_tilde = [] for ix , g in enumerate ( self . bootclustid ): beta_1g_tilde . append ( np . linalg . pinv ( tX1X1 - tX1gX1g_list [ ix ]) @ ( tX1y - tX1gyg_list [ ix ])) beta = beta_1g_tilde M = tXgX1g_list elif self . bootstrap_type in [ \"WCU3x\" ]: beta_g_hat = [] for ix , g in enumerate ( self . bootclustid ): beta_g_hat . append ( np . linalg . pinv ( self . tXX - self . tXgXg_list [ ix ]) @ ( self . tXy - self . tXgyg_list [ ix ])) beta = beta_g_hat M = self . tXgXg_list elif self . bootstrap_type in [ \"WCR1x\" ]: A = 1 / ( np . transpose ( self . R ) @ self . tXXinv @ self . R ) beta_tilde = self . beta_hat - self . tXXinv @ self . R * A * ( self . R @ self . beta_hat - 0 ) beta = beta_tilde M = self . tXgXg_list elif self . bootstrap_type in [ \"WCU1x\" ]: beta = self . beta_hat M = self . tXgXg_list # compute scores based on tXgyg, M, beta scores_list = [] if ( self . bootstrap_type in [ \"WCR1x\" , \"WCU1x\" ]): for ix , g in enumerate ( self . bootclustid ): scores_list . append ( self . tXgyg_list [ ix ] - M [ ix ] @ beta ) elif ( self . bootstrap_type in [ \"WCR3x\" , \"WCU3x\" ]): for ix , g in enumerate ( self . bootclustid ): scores_list . append ( self . tXgyg_list [ ix ] - M [ ix ] @ beta [ ix ]) self . scores_mat = np . transpose ( np . array ( scores_list )) # k x G return self . scores_mat def get_numer ( self ): # Calculate the bootstrap numerator self . Cg = self . R @ self . tXXinv @ self . scores_mat self . numer = self . Cg @ self . v def get_denom ( self ): if self . crv_type == \"crv1\" : H = np . zeros (( self . G , self . G )) # numba optimization possible? for ixg , g in enumerate ( self . bootclustid ): for ixh , h in enumerate ( self . bootclustid ): # can be improved by replacing list calls with matrices; H [ ixg , ixh ] = self . R @ self . tXXinv @ self . tXgXg_list [ ixg ] @ self . tXXinv @ self . scores_mat [:, ixh ] # now compute denominator # numba / cython / c++ optimization possible? Porting this part from # R to c++ gives good speed improvements @jit def compute_denom ( Cg , H , bootclustid , B , G , v , ssc ): denom = np . zeros ( B ) for b in range ( 0 , B ): Zg = np . zeros ( G ) for ixg , g in enumerate ( bootclustid ): vH = 0 for ixh , h in enumerate ( bootclustid ): vH += v [ ixh , b ] * H [ ixg , ixh ] Zg [ ixg ] = Cg [ ixg ] * v [ ixg , b ] - vH # todo: ssc denom [ b ] = ssc * np . sum ( np . power ( Zg , 2 )) return denom self . denom = compute_denom ( self . Cg , H , self . bootclustid , self . B , self . G , self . v , self . ssc ) elif self . crv_type == \"crv3\" : self . inv_tXX_tXgXg = [] for ix , g in enumerate ( self . bootclustid ): self . inv_tXX_tXgXg . append ( np . linalg . pinv ( self . tXX - self . tXgXg_list [ ix ])) self . denom = np . zeros ( self . B ) for b in range ( 0 , self . B ): scores_g_boot = np . zeros (( self . G , self . k )) v_ = self . v [:, b ] for ixg , g in enumerate ( self . bootclustid ): scores_g_boot [ ixg ,:] = self . scores_mat [:, ixg ] * v_ [ ixg ] scores_boot = np . sum ( scores_g_boot , axis = 0 ) delta_b_star = self . tXXinv @ scores_boot delta_diff = np . zeros (( self . G , self . k )) for ixg , g in enumerate ( self . bootclustid ): score_diff = scores_boot - scores_g_boot [ ixg ,:] delta_diff [ ixg ,:] = ( ( self . inv_tXX_tXgXg [ ixg ] @ score_diff - delta_b_star ) ** 2 ) # se's self . denom [ b ] = self . ssc * np . sum ( delta_diff , axis = 0 )[ np . where ( self . R == 1 )] def get_tboot ( self ): self . t_boot = self . numer / np . sqrt ( self . denom ) def get_vcov ( self ): if self . crv_type == \"crv1\" : meat = np . zeros (( self . k , self . k )) for ixg , g in enumerate ( self . bootclustid ): score = np . transpose ( self . X_list [ ixg ]) @ ( self . Y_list [ ixg ] - self . X_list [ ixg ] @ self . beta_hat ) meat += np . outer ( score , score ) self . vcov = self . tXXinv @ meat @ self . tXXinv elif self . crv_type == \"crv3\" : # calculate leave-one out beta hat beta_jack = np . zeros (( self . G , self . k )) for ixg , g in enumerate ( self . bootclustid ): beta_jack [ ixg ,:] = ( np . linalg . pinv ( self . tXX - self . tXgXg_list [ ixg ]) @ ( self . tXy - np . transpose ( self . X_list [ ixg ]) @ self . Y_list [ ixg ]) ) if not hasattr ( self , \"beta_hat\" ): beta_hat = self . tXXinv @ self . tXy beta_center = self . beta_hat vcov3 = np . zeros (( self . k , self . k )) for ixg , g in enumerate ( self . bootclustid ): beta_centered = beta_jack [ ixg ,:] - beta_center vcov3 += np . outer ( beta_centered , beta_centered ) self . vcov = vcov3 def get_tstat ( self ): se = np . sqrt ( self . ssc * self . R @ self . vcov @ np . transpose ( self . R )) t_stats = self . beta_hat / se self . t_stat = t_stats [ np . where ( self . R == 1 )] def get_pvalue ( self , pval_type = \"two-tailed\" ): if pval_type == \"two-tailed\" : self . pvalue = np . mean ( np . abs ( self . t_stat ) < abs ( self . t_boot )) elif pval_type == \"equal-tailed\" : pl = np . mean ( self . t_stat < self . t_boot ) ph = np . mean ( self . t_stat > self . t_boot ) self . pvalue = 2 * min ( pl , ph ) elif pval_type == \">\" : self . pvalue = np . mean ( self . t_stat < self . t_boot ) else : self . pvalue = np . mean ( self . t_stat > self . t_boot ) __init__ ( X , Y , cluster , R , B , bootcluster = None , seed = None ) Initializes the Wild Cluster Bootstrap Class Parameters: Name Type Description Default X Union [ np . ndarray , pd . DataFrame , pd . Series ] Exogeneous variable array or dataframe required Y Union [ np . ndarray , pd . DataFrame , pd . Series ] Endogenous variable array or dataframe required cluster Union [ np . ndarray , pd . DataFrame , pd . Series ] Cluster array or dataframe required R Union [ np . ndarray , pd . DataFrame ] Constraint matrix for running bootstrap required B int bootstrap iterations required bootcluster Union [ np . ndarray , pd . DataFrame , pd . Series , None] Sub-cluster array. Defaults to None. None seed Union [ int , None] Random seed for random weight types. Defaults to None. None Raises: Type Description TypeError Raise if input arrays are lists TestMatrixNonConformabilityException Raise if constraint matrix shape does not conform to X Source code in wildboottest\\wildboottest.py 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 def __init__ ( self , X : Union [ np . ndarray , pd . DataFrame , pd . Series ], Y : Union [ np . ndarray , pd . DataFrame , pd . Series ], cluster : Union [ np . ndarray , pd . DataFrame , pd . Series ], R : Union [ np . ndarray , pd . DataFrame ], B : int , bootcluster : Union [ np . ndarray , pd . DataFrame , pd . Series , None ] = None , seed : Union [ int , None ] = None ) -> None : \"\"\"Initializes the Wild Cluster Bootstrap Class Args: X (Union[np.ndarray, pd.DataFrame, pd.Series]): Exogeneous variable array or dataframe Y (Union[np.ndarray, pd.DataFrame, pd.Series]): Endogenous variable array or dataframe cluster (Union[np.ndarray, pd.DataFrame, pd.Series]): Cluster array or dataframe R (Union[np.ndarray, pd.DataFrame]): Constraint matrix for running bootstrap B (int): bootstrap iterations bootcluster (Union[np.ndarray, pd.DataFrame, pd.Series, None], optional): Sub-cluster array. Defaults to None. seed (Union[int, None], optional): Random seed for random weight types. Defaults to None. Raises: TypeError: Raise if input arrays are lists TestMatrixNonConformabilityException: Raise if constraint matrix shape does not conform to X \"\"\" \"Initialize the WildboottestCL class\" #assert bootstrap_type in ['11', '13', '31', '33'] #assert impose_null in [True, False] if bootcluster is None : bootcluster = cluster for i in [ X , Y , cluster , bootcluster ]: if isinstance ( i , list ): raise TypeError ( f \" { i } cannot be a list\" ) if isinstance ( X , ( pd . DataFrame , pd . Series )): self . X = X . values else : self . X = X if isinstance ( Y , ( pd . DataFrame , pd . Series )): self . Y = Y . values else : self . Y = Y if isinstance ( cluster , pd . DataFrame ): self . clustid = cluster . unique () self . cluster = cluster . values if isinstance ( bootcluster , pd . DataFrame ): self . bootclustid = bootcluster . unique () self . bootcluster = bootcluster . values else : self . clustid = np . unique ( cluster ) self . bootclustid = np . unique ( bootcluster ) self . bootcluster = bootcluster if isinstance ( seed , int ): np . random . seed ( seed ) self . N_G_bootcluster = len ( self . bootclustid ) self . G = len ( self . clustid ) self . N = X . shape [ 0 ] self . k = X . shape [ 1 ] self . B = B self . R = R if self . X . shape [ 1 ] != self . R . shape [ 0 ]: raise TestMatrixNonConformabilityException ( \"The number of rows in the test matrix R, does not \" ) X_list = [] y_list = [] tXgXg_list = [] tXgyg_list = [] tXX = np . zeros (( self . k , self . k )) tXy = np . zeros ( self . k ) #all_cluster = np.unique(bootcluster) for g in self . bootclustid : # split X and Y by (boot)cluster X_g = self . X [ np . where ( self . bootcluster == g )] Y_g = self . Y [ np . where ( self . bootcluster == g )] tXgXg = np . transpose ( X_g ) @ X_g tXgyg = np . transpose ( X_g ) @ Y_g X_list . append ( X_g ) y_list . append ( Y_g ) tXgXg_list . append ( tXgXg ) tXgyg_list . append ( tXgyg ) tXX += tXgXg tXy += tXgyg self . X_list = X_list self . Y_list = y_list self . tXgXg_list = tXgXg_list self . tXgyg_list = tXgyg_list self . tXX = tXX self . tXy = tXy self . tXXinv = np . linalg . inv ( tXX ) self . RtXXinv = np . matmul ( R , self . tXXinv ) get_scores ( bootstrap_type , impose_null , adj = True , cluster_adj = True ) Run bootstrap and get scores for each variable Parameters: Name Type Description Default bootstrap_type str Determines which wild cluster bootstrap type should be run. Options are \"fnw11\",\"11\", \"13\", \"31\" and \"33\" for the wild cluster bootstrap and \"11\" and \"31\" for the heteroskedastic bootstrap. For more information, see the details section. \"fnw11\" is the default for the cluster bootstrap, which runs a \"11\" type wild cluster bootstrap via the algorithm outlined in \"fast and wild\" (Roodman et al (2019)). \"11\" is the default for the heteroskedastic bootstrap. required impose_null bool Controls if the null hypothesis is imposed on the bootstrap dgp or not. Null imposed (WCR) by default. If False, the null is not imposed (WCU) required adj bool Whether to adjust for small sample. Defaults to True. True cluster_adj bool Whether to do a cluster-robust small sample correction. Defaults to True. True Returns: Type Description np . ndarray np.ndarray: The output array of scores of shape kxG Source code in wildboottest\\wildboottest.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 def get_scores ( self , bootstrap_type : str , impose_null : bool , adj : bool = True , cluster_adj : bool = True ) -> np . ndarray : \"\"\"Run bootstrap and get scores for each variable Args: bootstrap_type (str): Determines which wild cluster bootstrap type should be run. Options are \"fnw11\",\"11\", \"13\", \"31\" and \"33\" for the wild cluster bootstrap and \"11\" and \"31\" for the heteroskedastic bootstrap. For more information, see the details section. \"fnw11\" is the default for the cluster bootstrap, which runs a \"11\" type wild cluster bootstrap via the algorithm outlined in \"fast and wild\" (Roodman et al (2019)). \"11\" is the default for the heteroskedastic bootstrap. impose_null (bool): Controls if the null hypothesis is imposed on the bootstrap dgp or not. Null imposed (WCR) by default. If False, the null is not imposed (WCU) adj (bool, optional): Whether to adjust for small sample. Defaults to True. cluster_adj (bool, optional): Whether to do a cluster-robust small sample correction. Defaults to True. Returns: np.ndarray: The output array of scores of shape kxG \"\"\" if bootstrap_type [ 1 : 2 ] == '1' : self . crv_type = \"crv1\" self . ssc = 1 if adj : self . ssc = self . ssc * ( self . N - 1 ) / ( self . N - self . k ) if cluster_adj : self . ssc = self . ssc * self . G / ( self . G - 1 ) elif bootstrap_type [ 1 : 2 ] == '3' : self . crv_type = \"crv3\" self . ssc = ( self . G - 1 ) / self . G bootstrap_type_x = bootstrap_type [ 0 : 1 ] + 'x' if impose_null == True : self . bootstrap_type = \"WCR\" + bootstrap_type_x else : self . bootstrap_type = \"WCU\" + bootstrap_type_x # not needed for all types, but compute anyways self . beta_hat = self . tXXinv @ self . tXy # precompute required objects for computing scores & vcov's if self . bootstrap_type in [ \"WCR3x\" ]: X = self . X X1 = X [:, self . R == 0 ] X1_list = [] tX1gX1g_list = [] tX1gyg_list = [] tXgX1g_list = [] tX1X1 = np . zeros (( self . k - 1 , self . k - 1 )) tX1y = np . zeros ( self . k - 1 ) for ix , g in enumerate ( self . bootclustid ): #ix = g = 1 X1_list . append ( X1 [ np . where ( self . bootcluster == g )]) tX1gX1g_list . append ( np . transpose ( X1_list [ ix ]) @ X1_list [ ix ]) tX1gyg_list . append ( np . transpose ( X1_list [ ix ]) @ self . Y_list [ ix ]) tXgX1g_list . append ( np . transpose ( self . X_list [ ix ]) @ X1_list [ ix ]) tX1X1 = tX1X1 + tX1gX1g_list [ ix ] tX1y = tX1y + tX1gyg_list [ ix ] beta_1g_tilde = [] for ix , g in enumerate ( self . bootclustid ): beta_1g_tilde . append ( np . linalg . pinv ( tX1X1 - tX1gX1g_list [ ix ]) @ ( tX1y - tX1gyg_list [ ix ])) beta = beta_1g_tilde M = tXgX1g_list elif self . bootstrap_type in [ \"WCU3x\" ]: beta_g_hat = [] for ix , g in enumerate ( self . bootclustid ): beta_g_hat . append ( np . linalg . pinv ( self . tXX - self . tXgXg_list [ ix ]) @ ( self . tXy - self . tXgyg_list [ ix ])) beta = beta_g_hat M = self . tXgXg_list elif self . bootstrap_type in [ \"WCR1x\" ]: A = 1 / ( np . transpose ( self . R ) @ self . tXXinv @ self . R ) beta_tilde = self . beta_hat - self . tXXinv @ self . R * A * ( self . R @ self . beta_hat - 0 ) beta = beta_tilde M = self . tXgXg_list elif self . bootstrap_type in [ \"WCU1x\" ]: beta = self . beta_hat M = self . tXgXg_list # compute scores based on tXgyg, M, beta scores_list = [] if ( self . bootstrap_type in [ \"WCR1x\" , \"WCU1x\" ]): for ix , g in enumerate ( self . bootclustid ): scores_list . append ( self . tXgyg_list [ ix ] - M [ ix ] @ beta ) elif ( self . bootstrap_type in [ \"WCR3x\" , \"WCU3x\" ]): for ix , g in enumerate ( self . bootclustid ): scores_list . append ( self . tXgyg_list [ ix ] - M [ ix ] @ beta [ ix ]) self . scores_mat = np . transpose ( np . array ( scores_list )) # k x G return self . scores_mat get_weights ( weights_type ) Function for getting weights for bootstrapping. Parameters: Name Type Description Default weights_type Tuple [ str , Callable ] The distribution to be used. Accepts Either 'rademacher', 'mammen', 'norm' or 'webb'. Optionally accepts a callable of one argument, n , the number of bootstraps iterations. required Returns: Type Description Tuple [ np . ndarray , int , bool ] Tuple[np.ndarray, int]: Returns the arrays of weights and the number of bootstrap iterations Source code in wildboottest\\wildboottest.py 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 def get_weights ( self , weights_type : Union [ str , Callable ]) -> Tuple [ np . ndarray , int , bool ]: \"\"\"Function for getting weights for bootstrapping. Args: weights_type (Tuple[str, Callable]): The distribution to be used. Accepts Either 'rademacher', 'mammen', 'norm' or 'webb'. Optionally accepts a callable of one argument, `n`, the number of bootstraps iterations. Returns: Tuple[np.ndarray, int]: Returns the arrays of weights and the number of bootstrap iterations \"\"\" self . weights_type = weights_type if 2 ** self . N_G_bootcluster < self . B and weights_type == 'rademacher' : self . full_enumeration = True full_enumeration_warn = True else : self . full_enumeration = False full_enumeration_warn = False self . v , self . B = draw_weights ( t = self . weights_type , full_enumeration = self . full_enumeration , N_G_bootcluster = self . N_G_bootcluster , boot_iter = self . B ) return self . v , self . B , full_enumeration_warn Create an object of WildboottestHC and get p-value by successively applying methods in the following way: Example import numpy as np from wildboottest.wildboottest import WildboottestHC np.random.seed(12312312) N = 1000 k = 3 G = 10 X = np.random.normal(0, 1, N * k).reshape((N,k)) beta = np.random.normal(0,1,k) beta[0] = 0.005 u = np.random.normal(0,1,N) Y = 1 + X @ beta + u R = np.array([1, 0, 0]) B = 999 run the wild bootstrap wb = WildboottestHC(X = X, Y = Y, R = R, B = B) wb.get_adjustments(bootstrap_type = '11') wb.get_uhat(impose_null = True) wb.get_tboot(weights_type = \"webb\") wb.get_tstat() wb.get_pvalue() Source code in wildboottest\\wildboottest.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 class WildboottestHC : \"\"\" Create an object of WildboottestHC and get p-value by successively applying methods in the following way: Example: >>> import numpy as np >>> from wildboottest.wildboottest import WildboottestHC >>> np.random.seed(12312312) >>> N = 1000 >>> k = 3 >>> G = 10 >>> X = np.random.normal(0, 1, N * k).reshape((N,k)) >>> beta = np.random.normal(0,1,k) >>> beta[0] = 0.005 >>> u = np.random.normal(0,1,N) >>> Y = 1 + X @ beta + u >>> R = np.array([1, 0, 0]) >>> B = 999 >>> # run the wild bootstrap >>> wb = WildboottestHC(X = X, Y = Y, R = R, B = B) >>> wb.get_adjustments(bootstrap_type = '11') >>> wb.get_uhat(impose_null = True) >>> wb.get_tboot(weights_type = \"webb\") >>> wb.get_tstat() >>> wb.get_pvalue() \"\"\" def __init__ ( self , X : Union [ np . ndarray , pd . DataFrame , pd . Series ], Y : Union [ np . ndarray , pd . DataFrame , pd . Series ], R : Union [ np . ndarray , pd . DataFrame ], B : int , seed : Union [ int , None ] = None ) -> None : \"\"\"Initializes the Heteroskedastic Wild Bootstrap Class Args: X (Union[np.ndarray, pd.DataFrame, pd.Series]): Exogeneous variable array or dataframe Y (Union[np.ndarray, pd.DataFrame, pd.Series]): Endogenous variable array or dataframe R (Union[np.ndarray, pd.DataFrame]): Constraint matrix for running bootstrap B (int): bootstrap iterations seed (Union[int, None], optional): Random seed for random weight types. Defaults to None. Raises: TypeError: Raise if input arrays are lists TestMatrixNonConformabilityException: Raise if constraint matrix shape does not conform to X \"\"\" for i in [ X , Y ]: if isinstance ( i , list ): raise TypeError ( f \" { i } cannot be a list\" ) if isinstance ( X , ( pd . DataFrame , pd . Series )): self . X = X . values else : self . X = X if isinstance ( Y , ( pd . DataFrame , pd . Series )): self . Y = Y . values else : self . Y = Y if isinstance ( seed , int ): np . random . seed ( seed ) self . N = X . shape [ 0 ] self . k = X . shape [ 1 ] self . B = B self . R = R if self . X . shape [ 1 ] != self . R . shape [ 0 ]: raise TestMatrixNonConformabilityException ( \"The number of rows in the test matrix R, does not \" ) def get_adjustments ( self , bootstrap_type ): ''' Raises: TestBootstrapTypeException: If non-appropriate bootstrap types are selected ''' if bootstrap_type not in [ '11' , '22' , '33' ]: raise TestBootstrapTypeException ( \"For the heteroskedastic (i.e. non-clustered) wild bootstrap, only types '11', '22' and '33' are supported.\" ) # allow for arbitrary different adjustments for bootstrap and standard t-stat self . tXXinv = np . linalg . inv ( np . transpose ( self . X ) @ self . X ) self . resid_multiplier_boot , self . small_sample_correction = _adjust_scores ( self . X , self . tXXinv , bootstrap_type [ 0 ]) if bootstrap_type [ 0 ] == bootstrap_type [ 1 ]: self . resid_multiplier_stat = self . resid_multiplier_boot else : self . resid_multiplier_stat = _adjust_scores ( self . X , self . tXXinv , bootstrap_type [ 1 ]) def get_uhat ( self , impose_null : bool ): ''' Raises: TestHCImposeNullException: If the null is not imposed on the bootstrap dgp ''' if impose_null is not True : raise TestHCImposeNullException ( 'For the heteroskedastic bootstrap, the null needs to be imposed.' ) self . tXy = np . transpose ( self . X ) @ self . Y self . beta_hat = self . tXXinv @ self . tXy self . uhat = self . Y - self . X @ self . beta_hat self . uhat_stat = self . uhat * self . resid_multiplier_stat if impose_null : self . impose_null = True r = 0 self . beta_r = self . beta_hat - self . tXXinv @ self . R * ( 1 / ( np . transpose ( self . R ) @ self . tXXinv @ self . R )) * ( np . transpose ( self . R ) @ self . beta_hat - r ) #self.uhat_r = self.Y - self.beta_r self . uhat_r = self . Y - self . X @ self . beta_r self . uhat2 = self . uhat_r * self . resid_multiplier_boot else : self . impose_null = False self . uhat2 = self . uhat * self . resid_multiplier_boot def get_tboot ( self , weights_type : Union [ str , Callable ]): if weights_type not in [ 'rademacher' , 'normal' ]: raise TestHCWeightsException ( \"For the heteroskedastic bootstrap, only weight tyes 'rademacher' and 'normal' are supported, but you provided\" + weight_type + \".\" ) self . weights_type = weights_type k = np . where ( self . R == 1 ) self . tXXinvX = self . tXXinv @ np . transpose ( self . X ) if self . impose_null == True : beta = self . beta_r . reshape (( self . k , 1 )) else : beta = self . beta_hat . reshape (( self . k , 1 )) yhat = ( self . X @ beta ) . flatten () R = self . R . reshape (( self . k , 1 )) self . RXXinvX_2 = np . power ( np . transpose ( R ) @ self . tXXinv @ np . transpose ( self . X ), 2 ) #RXXinv_2 = np.power(np.transpose(R) @ self.tXXinv, 2) @njit ( parallel = True ) def _run_hc_bootstrap ( B , weights_type , N , X , yhat , uhat2 , tXXinv , RXXinvX_2 , Rt , small_sample_correction ): #rng = np.random.default_rng() t_boot = np . zeros ( B ) tXXinvX = tXXinv @ np . transpose ( X ) for b in prange ( 0 , B ): # create weights vector. mammen weights not supported via numba v = np . zeros ( N ) if weights_type == 'rademacher' : for i in range ( 0 , N ): v [ i ] = np . random . choice ( np . array ([ - 1 , 1 ])) else : v = np . zeros ( N ) for i in range ( 0 , N ): v [ i ] = np . random . normal () uhat_boot = uhat2 * v yhat_boot = yhat + uhat_boot beta_boot = tXXinvX @ yhat_boot resid_boot = yhat_boot - X @ beta_boot cov_v = small_sample_correction * RXXinvX_2 @ np . power ( resid_boot , 2 ) t_boot [ b ] = ( Rt @ beta_boot / np . sqrt ( cov_v ))[ 0 ] return t_boot self . t_boot = _run_hc_bootstrap ( B = self . B , weights_type = self . weights_type , N = self . N , X = self . X , yhat = yhat , uhat2 = self . uhat2 , tXXinv = self . tXXinv , RXXinvX_2 = self . RXXinvX_2 , Rt = np . transpose ( R ), small_sample_correction = self . small_sample_correction ) def get_tstat ( self ): cov = self . small_sample_correction * self . RXXinvX_2 @ np . power ( self . uhat_stat , 2 ) self . t_stat = ( np . transpose ( self . R ) @ self . beta_hat / np . sqrt ( cov )) def get_pvalue ( self , pval_type = \"two-tailed\" ): if pval_type == \"two-tailed\" : self . pvalue = np . mean ( np . abs ( self . t_stat ) < abs ( self . t_boot )) elif pval_type == \"equal-tailed\" : pl = np . mean ( self . t_stat < self . t_boot ) ph = np . mean ( self . t_stat > self . t_boot ) self . pvalue = 2 * min ( pl , ph ) elif pval_type == \">\" : self . pvalue = np . mean ( self . t_stat < self . t_boot ) else : self . pvalue = np . mean ( self . t_stat > self . t_boot ) __init__ ( X , Y , R , B , seed = None ) Initializes the Heteroskedastic Wild Bootstrap Class Parameters: Name Type Description Default X Union [ np . ndarray , pd . DataFrame , pd . Series ] Exogeneous variable array or dataframe required Y Union [ np . ndarray , pd . DataFrame , pd . Series ] Endogenous variable array or dataframe required R Union [ np . ndarray , pd . DataFrame ] Constraint matrix for running bootstrap required B int bootstrap iterations required seed Union [ int , None] Random seed for random weight types. Defaults to None. None Raises: Type Description TypeError Raise if input arrays are lists TestMatrixNonConformabilityException Raise if constraint matrix shape does not conform to X Source code in wildboottest\\wildboottest.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def __init__ ( self , X : Union [ np . ndarray , pd . DataFrame , pd . Series ], Y : Union [ np . ndarray , pd . DataFrame , pd . Series ], R : Union [ np . ndarray , pd . DataFrame ], B : int , seed : Union [ int , None ] = None ) -> None : \"\"\"Initializes the Heteroskedastic Wild Bootstrap Class Args: X (Union[np.ndarray, pd.DataFrame, pd.Series]): Exogeneous variable array or dataframe Y (Union[np.ndarray, pd.DataFrame, pd.Series]): Endogenous variable array or dataframe R (Union[np.ndarray, pd.DataFrame]): Constraint matrix for running bootstrap B (int): bootstrap iterations seed (Union[int, None], optional): Random seed for random weight types. Defaults to None. Raises: TypeError: Raise if input arrays are lists TestMatrixNonConformabilityException: Raise if constraint matrix shape does not conform to X \"\"\" for i in [ X , Y ]: if isinstance ( i , list ): raise TypeError ( f \" { i } cannot be a list\" ) if isinstance ( X , ( pd . DataFrame , pd . Series )): self . X = X . values else : self . X = X if isinstance ( Y , ( pd . DataFrame , pd . Series )): self . Y = Y . values else : self . Y = Y if isinstance ( seed , int ): np . random . seed ( seed ) self . N = X . shape [ 0 ] self . k = X . shape [ 1 ] self . B = B self . R = R if self . X . shape [ 1 ] != self . R . shape [ 0 ]: raise TestMatrixNonConformabilityException ( \"The number of rows in the test matrix R, does not \" ) get_adjustments ( bootstrap_type ) Raises: TestBootstrapTypeException: If non-appropriate bootstrap types are selected Source code in wildboottest\\wildboottest.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def get_adjustments ( self , bootstrap_type ): ''' Raises: TestBootstrapTypeException: If non-appropriate bootstrap types are selected ''' if bootstrap_type not in [ '11' , '22' , '33' ]: raise TestBootstrapTypeException ( \"For the heteroskedastic (i.e. non-clustered) wild bootstrap, only types '11', '22' and '33' are supported.\" ) # allow for arbitrary different adjustments for bootstrap and standard t-stat self . tXXinv = np . linalg . inv ( np . transpose ( self . X ) @ self . X ) self . resid_multiplier_boot , self . small_sample_correction = _adjust_scores ( self . X , self . tXXinv , bootstrap_type [ 0 ]) if bootstrap_type [ 0 ] == bootstrap_type [ 1 ]: self . resid_multiplier_stat = self . resid_multiplier_boot else : self . resid_multiplier_stat = _adjust_scores ( self . X , self . tXXinv , bootstrap_type [ 1 ]) get_uhat ( impose_null ) Raises: TestHCImposeNullException: If the null is not imposed on the bootstrap dgp Source code in wildboottest\\wildboottest.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def get_uhat ( self , impose_null : bool ): ''' Raises: TestHCImposeNullException: If the null is not imposed on the bootstrap dgp ''' if impose_null is not True : raise TestHCImposeNullException ( 'For the heteroskedastic bootstrap, the null needs to be imposed.' ) self . tXy = np . transpose ( self . X ) @ self . Y self . beta_hat = self . tXXinv @ self . tXy self . uhat = self . Y - self . X @ self . beta_hat self . uhat_stat = self . uhat * self . resid_multiplier_stat if impose_null : self . impose_null = True r = 0 self . beta_r = self . beta_hat - self . tXXinv @ self . R * ( 1 / ( np . transpose ( self . R ) @ self . tXXinv @ self . R )) * ( np . transpose ( self . R ) @ self . beta_hat - r ) #self.uhat_r = self.Y - self.beta_r self . uhat_r = self . Y - self . X @ self . beta_r self . uhat2 = self . uhat_r * self . resid_multiplier_boot else : self . impose_null = False self . uhat2 = self . uhat * self . resid_multiplier_boot","title":"WildBoottest"},{"location":"base/#wildboottest.wildboottest.WildboottestCL--preliminaries-load-libraries-and-create-data","text":"import numpy as np from wildboottest.wildboottest import WildboottestCL np.random.seed(12312312) N = 1000 k = 3 G = 10 X = np.random.normal(0, 1, N * k).reshape((N,k)) beta = np.random.normal(0,1,k) beta[0] = 0.005 u = np.random.normal(0,1,N) Y = 1 + X @ beta + u cluster = np.random.choice(list(range(0,G)), N) R = np.array([1, 0, 0]) B = 999","title":"preliminaries: load libraries and create data"},{"location":"base/#wildboottest.wildboottest.WildboottestCL--run-the-wild-cluster-bootstrap","text":"wb = WildboottestCL(X = X, Y = Y, cluster = cluster, R = R, B = B) wb.get_scores(bootstrap_type = \"11\", impose_null = True) wb.get_weights(weights_type= \"rademacher\") wb.get_numer() wb.get_denom() wb.get_tboot() wb.get_vcov() wb.get_tstat() wb.get_pvalue() Source code in wildboottest\\wildboottest.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 class WildboottestCL : \"\"\" Create an object of WildboottestCL and get p-value by successively applying methods in the following way: Example: >>> # preliminaries: load libraries and create data >>> import numpy as np >>> from wildboottest.wildboottest import WildboottestCL >>> np.random.seed(12312312) >>> N = 1000 >>> k = 3 >>> G = 10 >>> X = np.random.normal(0, 1, N * k).reshape((N,k)) >>> beta = np.random.normal(0,1,k) >>> beta[0] = 0.005 >>> u = np.random.normal(0,1,N) >>> Y = 1 + X @ beta + u >>> cluster = np.random.choice(list(range(0,G)), N) >>> R = np.array([1, 0, 0]) >>> B = 999 >>> # run the wild cluster bootstrap >>> wb = WildboottestCL(X = X, Y = Y, cluster = cluster, R = R, B = B) >>> wb.get_scores(bootstrap_type = \"11\", impose_null = True) >>> wb.get_weights(weights_type= \"rademacher\") >>> wb.get_numer() >>> wb.get_denom() >>> wb.get_tboot() >>> wb.get_vcov() >>> wb.get_tstat() >>> wb.get_pvalue() \"\"\" def __init__ ( self , X : Union [ np . ndarray , pd . DataFrame , pd . Series ], Y : Union [ np . ndarray , pd . DataFrame , pd . Series ], cluster : Union [ np . ndarray , pd . DataFrame , pd . Series ], R : Union [ np . ndarray , pd . DataFrame ], B : int , bootcluster : Union [ np . ndarray , pd . DataFrame , pd . Series , None ] = None , seed : Union [ int , None ] = None ) -> None : \"\"\"Initializes the Wild Cluster Bootstrap Class Args: X (Union[np.ndarray, pd.DataFrame, pd.Series]): Exogeneous variable array or dataframe Y (Union[np.ndarray, pd.DataFrame, pd.Series]): Endogenous variable array or dataframe cluster (Union[np.ndarray, pd.DataFrame, pd.Series]): Cluster array or dataframe R (Union[np.ndarray, pd.DataFrame]): Constraint matrix for running bootstrap B (int): bootstrap iterations bootcluster (Union[np.ndarray, pd.DataFrame, pd.Series, None], optional): Sub-cluster array. Defaults to None. seed (Union[int, None], optional): Random seed for random weight types. Defaults to None. Raises: TypeError: Raise if input arrays are lists TestMatrixNonConformabilityException: Raise if constraint matrix shape does not conform to X \"\"\" \"Initialize the WildboottestCL class\" #assert bootstrap_type in ['11', '13', '31', '33'] #assert impose_null in [True, False] if bootcluster is None : bootcluster = cluster for i in [ X , Y , cluster , bootcluster ]: if isinstance ( i , list ): raise TypeError ( f \" { i } cannot be a list\" ) if isinstance ( X , ( pd . DataFrame , pd . Series )): self . X = X . values else : self . X = X if isinstance ( Y , ( pd . DataFrame , pd . Series )): self . Y = Y . values else : self . Y = Y if isinstance ( cluster , pd . DataFrame ): self . clustid = cluster . unique () self . cluster = cluster . values if isinstance ( bootcluster , pd . DataFrame ): self . bootclustid = bootcluster . unique () self . bootcluster = bootcluster . values else : self . clustid = np . unique ( cluster ) self . bootclustid = np . unique ( bootcluster ) self . bootcluster = bootcluster if isinstance ( seed , int ): np . random . seed ( seed ) self . N_G_bootcluster = len ( self . bootclustid ) self . G = len ( self . clustid ) self . N = X . shape [ 0 ] self . k = X . shape [ 1 ] self . B = B self . R = R if self . X . shape [ 1 ] != self . R . shape [ 0 ]: raise TestMatrixNonConformabilityException ( \"The number of rows in the test matrix R, does not \" ) X_list = [] y_list = [] tXgXg_list = [] tXgyg_list = [] tXX = np . zeros (( self . k , self . k )) tXy = np . zeros ( self . k ) #all_cluster = np.unique(bootcluster) for g in self . bootclustid : # split X and Y by (boot)cluster X_g = self . X [ np . where ( self . bootcluster == g )] Y_g = self . Y [ np . where ( self . bootcluster == g )] tXgXg = np . transpose ( X_g ) @ X_g tXgyg = np . transpose ( X_g ) @ Y_g X_list . append ( X_g ) y_list . append ( Y_g ) tXgXg_list . append ( tXgXg ) tXgyg_list . append ( tXgyg ) tXX += tXgXg tXy += tXgyg self . X_list = X_list self . Y_list = y_list self . tXgXg_list = tXgXg_list self . tXgyg_list = tXgyg_list self . tXX = tXX self . tXy = tXy self . tXXinv = np . linalg . inv ( tXX ) self . RtXXinv = np . matmul ( R , self . tXXinv ) def get_weights ( self , weights_type : Union [ str , Callable ]) -> Tuple [ np . ndarray , int , bool ]: \"\"\"Function for getting weights for bootstrapping. Args: weights_type (Tuple[str, Callable]): The distribution to be used. Accepts Either 'rademacher', 'mammen', 'norm' or 'webb'. Optionally accepts a callable of one argument, `n`, the number of bootstraps iterations. Returns: Tuple[np.ndarray, int]: Returns the arrays of weights and the number of bootstrap iterations \"\"\" self . weights_type = weights_type if 2 ** self . N_G_bootcluster < self . B and weights_type == 'rademacher' : self . full_enumeration = True full_enumeration_warn = True else : self . full_enumeration = False full_enumeration_warn = False self . v , self . B = draw_weights ( t = self . weights_type , full_enumeration = self . full_enumeration , N_G_bootcluster = self . N_G_bootcluster , boot_iter = self . B ) return self . v , self . B , full_enumeration_warn def get_scores ( self , bootstrap_type : str , impose_null : bool , adj : bool = True , cluster_adj : bool = True ) -> np . ndarray : \"\"\"Run bootstrap and get scores for each variable Args: bootstrap_type (str): Determines which wild cluster bootstrap type should be run. Options are \"fnw11\",\"11\", \"13\", \"31\" and \"33\" for the wild cluster bootstrap and \"11\" and \"31\" for the heteroskedastic bootstrap. For more information, see the details section. \"fnw11\" is the default for the cluster bootstrap, which runs a \"11\" type wild cluster bootstrap via the algorithm outlined in \"fast and wild\" (Roodman et al (2019)). \"11\" is the default for the heteroskedastic bootstrap. impose_null (bool): Controls if the null hypothesis is imposed on the bootstrap dgp or not. Null imposed (WCR) by default. If False, the null is not imposed (WCU) adj (bool, optional): Whether to adjust for small sample. Defaults to True. cluster_adj (bool, optional): Whether to do a cluster-robust small sample correction. Defaults to True. Returns: np.ndarray: The output array of scores of shape kxG \"\"\" if bootstrap_type [ 1 : 2 ] == '1' : self . crv_type = \"crv1\" self . ssc = 1 if adj : self . ssc = self . ssc * ( self . N - 1 ) / ( self . N - self . k ) if cluster_adj : self . ssc = self . ssc * self . G / ( self . G - 1 ) elif bootstrap_type [ 1 : 2 ] == '3' : self . crv_type = \"crv3\" self . ssc = ( self . G - 1 ) / self . G bootstrap_type_x = bootstrap_type [ 0 : 1 ] + 'x' if impose_null == True : self . bootstrap_type = \"WCR\" + bootstrap_type_x else : self . bootstrap_type = \"WCU\" + bootstrap_type_x # not needed for all types, but compute anyways self . beta_hat = self . tXXinv @ self . tXy # precompute required objects for computing scores & vcov's if self . bootstrap_type in [ \"WCR3x\" ]: X = self . X X1 = X [:, self . R == 0 ] X1_list = [] tX1gX1g_list = [] tX1gyg_list = [] tXgX1g_list = [] tX1X1 = np . zeros (( self . k - 1 , self . k - 1 )) tX1y = np . zeros ( self . k - 1 ) for ix , g in enumerate ( self . bootclustid ): #ix = g = 1 X1_list . append ( X1 [ np . where ( self . bootcluster == g )]) tX1gX1g_list . append ( np . transpose ( X1_list [ ix ]) @ X1_list [ ix ]) tX1gyg_list . append ( np . transpose ( X1_list [ ix ]) @ self . Y_list [ ix ]) tXgX1g_list . append ( np . transpose ( self . X_list [ ix ]) @ X1_list [ ix ]) tX1X1 = tX1X1 + tX1gX1g_list [ ix ] tX1y = tX1y + tX1gyg_list [ ix ] beta_1g_tilde = [] for ix , g in enumerate ( self . bootclustid ): beta_1g_tilde . append ( np . linalg . pinv ( tX1X1 - tX1gX1g_list [ ix ]) @ ( tX1y - tX1gyg_list [ ix ])) beta = beta_1g_tilde M = tXgX1g_list elif self . bootstrap_type in [ \"WCU3x\" ]: beta_g_hat = [] for ix , g in enumerate ( self . bootclustid ): beta_g_hat . append ( np . linalg . pinv ( self . tXX - self . tXgXg_list [ ix ]) @ ( self . tXy - self . tXgyg_list [ ix ])) beta = beta_g_hat M = self . tXgXg_list elif self . bootstrap_type in [ \"WCR1x\" ]: A = 1 / ( np . transpose ( self . R ) @ self . tXXinv @ self . R ) beta_tilde = self . beta_hat - self . tXXinv @ self . R * A * ( self . R @ self . beta_hat - 0 ) beta = beta_tilde M = self . tXgXg_list elif self . bootstrap_type in [ \"WCU1x\" ]: beta = self . beta_hat M = self . tXgXg_list # compute scores based on tXgyg, M, beta scores_list = [] if ( self . bootstrap_type in [ \"WCR1x\" , \"WCU1x\" ]): for ix , g in enumerate ( self . bootclustid ): scores_list . append ( self . tXgyg_list [ ix ] - M [ ix ] @ beta ) elif ( self . bootstrap_type in [ \"WCR3x\" , \"WCU3x\" ]): for ix , g in enumerate ( self . bootclustid ): scores_list . append ( self . tXgyg_list [ ix ] - M [ ix ] @ beta [ ix ]) self . scores_mat = np . transpose ( np . array ( scores_list )) # k x G return self . scores_mat def get_numer ( self ): # Calculate the bootstrap numerator self . Cg = self . R @ self . tXXinv @ self . scores_mat self . numer = self . Cg @ self . v def get_denom ( self ): if self . crv_type == \"crv1\" : H = np . zeros (( self . G , self . G )) # numba optimization possible? for ixg , g in enumerate ( self . bootclustid ): for ixh , h in enumerate ( self . bootclustid ): # can be improved by replacing list calls with matrices; H [ ixg , ixh ] = self . R @ self . tXXinv @ self . tXgXg_list [ ixg ] @ self . tXXinv @ self . scores_mat [:, ixh ] # now compute denominator # numba / cython / c++ optimization possible? Porting this part from # R to c++ gives good speed improvements @jit def compute_denom ( Cg , H , bootclustid , B , G , v , ssc ): denom = np . zeros ( B ) for b in range ( 0 , B ): Zg = np . zeros ( G ) for ixg , g in enumerate ( bootclustid ): vH = 0 for ixh , h in enumerate ( bootclustid ): vH += v [ ixh , b ] * H [ ixg , ixh ] Zg [ ixg ] = Cg [ ixg ] * v [ ixg , b ] - vH # todo: ssc denom [ b ] = ssc * np . sum ( np . power ( Zg , 2 )) return denom self . denom = compute_denom ( self . Cg , H , self . bootclustid , self . B , self . G , self . v , self . ssc ) elif self . crv_type == \"crv3\" : self . inv_tXX_tXgXg = [] for ix , g in enumerate ( self . bootclustid ): self . inv_tXX_tXgXg . append ( np . linalg . pinv ( self . tXX - self . tXgXg_list [ ix ])) self . denom = np . zeros ( self . B ) for b in range ( 0 , self . B ): scores_g_boot = np . zeros (( self . G , self . k )) v_ = self . v [:, b ] for ixg , g in enumerate ( self . bootclustid ): scores_g_boot [ ixg ,:] = self . scores_mat [:, ixg ] * v_ [ ixg ] scores_boot = np . sum ( scores_g_boot , axis = 0 ) delta_b_star = self . tXXinv @ scores_boot delta_diff = np . zeros (( self . G , self . k )) for ixg , g in enumerate ( self . bootclustid ): score_diff = scores_boot - scores_g_boot [ ixg ,:] delta_diff [ ixg ,:] = ( ( self . inv_tXX_tXgXg [ ixg ] @ score_diff - delta_b_star ) ** 2 ) # se's self . denom [ b ] = self . ssc * np . sum ( delta_diff , axis = 0 )[ np . where ( self . R == 1 )] def get_tboot ( self ): self . t_boot = self . numer / np . sqrt ( self . denom ) def get_vcov ( self ): if self . crv_type == \"crv1\" : meat = np . zeros (( self . k , self . k )) for ixg , g in enumerate ( self . bootclustid ): score = np . transpose ( self . X_list [ ixg ]) @ ( self . Y_list [ ixg ] - self . X_list [ ixg ] @ self . beta_hat ) meat += np . outer ( score , score ) self . vcov = self . tXXinv @ meat @ self . tXXinv elif self . crv_type == \"crv3\" : # calculate leave-one out beta hat beta_jack = np . zeros (( self . G , self . k )) for ixg , g in enumerate ( self . bootclustid ): beta_jack [ ixg ,:] = ( np . linalg . pinv ( self . tXX - self . tXgXg_list [ ixg ]) @ ( self . tXy - np . transpose ( self . X_list [ ixg ]) @ self . Y_list [ ixg ]) ) if not hasattr ( self , \"beta_hat\" ): beta_hat = self . tXXinv @ self . tXy beta_center = self . beta_hat vcov3 = np . zeros (( self . k , self . k )) for ixg , g in enumerate ( self . bootclustid ): beta_centered = beta_jack [ ixg ,:] - beta_center vcov3 += np . outer ( beta_centered , beta_centered ) self . vcov = vcov3 def get_tstat ( self ): se = np . sqrt ( self . ssc * self . R @ self . vcov @ np . transpose ( self . R )) t_stats = self . beta_hat / se self . t_stat = t_stats [ np . where ( self . R == 1 )] def get_pvalue ( self , pval_type = \"two-tailed\" ): if pval_type == \"two-tailed\" : self . pvalue = np . mean ( np . abs ( self . t_stat ) < abs ( self . t_boot )) elif pval_type == \"equal-tailed\" : pl = np . mean ( self . t_stat < self . t_boot ) ph = np . mean ( self . t_stat > self . t_boot ) self . pvalue = 2 * min ( pl , ph ) elif pval_type == \">\" : self . pvalue = np . mean ( self . t_stat < self . t_boot ) else : self . pvalue = np . mean ( self . t_stat > self . t_boot )","title":"run the wild cluster bootstrap"},{"location":"base/#wildboottest.wildboottest.WildboottestCL.__init__","text":"Initializes the Wild Cluster Bootstrap Class Parameters: Name Type Description Default X Union [ np . ndarray , pd . DataFrame , pd . Series ] Exogeneous variable array or dataframe required Y Union [ np . ndarray , pd . DataFrame , pd . Series ] Endogenous variable array or dataframe required cluster Union [ np . ndarray , pd . DataFrame , pd . Series ] Cluster array or dataframe required R Union [ np . ndarray , pd . DataFrame ] Constraint matrix for running bootstrap required B int bootstrap iterations required bootcluster Union [ np . ndarray , pd . DataFrame , pd . Series , None] Sub-cluster array. Defaults to None. None seed Union [ int , None] Random seed for random weight types. Defaults to None. None Raises: Type Description TypeError Raise if input arrays are lists TestMatrixNonConformabilityException Raise if constraint matrix shape does not conform to X Source code in wildboottest\\wildboottest.py 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 def __init__ ( self , X : Union [ np . ndarray , pd . DataFrame , pd . Series ], Y : Union [ np . ndarray , pd . DataFrame , pd . Series ], cluster : Union [ np . ndarray , pd . DataFrame , pd . Series ], R : Union [ np . ndarray , pd . DataFrame ], B : int , bootcluster : Union [ np . ndarray , pd . DataFrame , pd . Series , None ] = None , seed : Union [ int , None ] = None ) -> None : \"\"\"Initializes the Wild Cluster Bootstrap Class Args: X (Union[np.ndarray, pd.DataFrame, pd.Series]): Exogeneous variable array or dataframe Y (Union[np.ndarray, pd.DataFrame, pd.Series]): Endogenous variable array or dataframe cluster (Union[np.ndarray, pd.DataFrame, pd.Series]): Cluster array or dataframe R (Union[np.ndarray, pd.DataFrame]): Constraint matrix for running bootstrap B (int): bootstrap iterations bootcluster (Union[np.ndarray, pd.DataFrame, pd.Series, None], optional): Sub-cluster array. Defaults to None. seed (Union[int, None], optional): Random seed for random weight types. Defaults to None. Raises: TypeError: Raise if input arrays are lists TestMatrixNonConformabilityException: Raise if constraint matrix shape does not conform to X \"\"\" \"Initialize the WildboottestCL class\" #assert bootstrap_type in ['11', '13', '31', '33'] #assert impose_null in [True, False] if bootcluster is None : bootcluster = cluster for i in [ X , Y , cluster , bootcluster ]: if isinstance ( i , list ): raise TypeError ( f \" { i } cannot be a list\" ) if isinstance ( X , ( pd . DataFrame , pd . Series )): self . X = X . values else : self . X = X if isinstance ( Y , ( pd . DataFrame , pd . Series )): self . Y = Y . values else : self . Y = Y if isinstance ( cluster , pd . DataFrame ): self . clustid = cluster . unique () self . cluster = cluster . values if isinstance ( bootcluster , pd . DataFrame ): self . bootclustid = bootcluster . unique () self . bootcluster = bootcluster . values else : self . clustid = np . unique ( cluster ) self . bootclustid = np . unique ( bootcluster ) self . bootcluster = bootcluster if isinstance ( seed , int ): np . random . seed ( seed ) self . N_G_bootcluster = len ( self . bootclustid ) self . G = len ( self . clustid ) self . N = X . shape [ 0 ] self . k = X . shape [ 1 ] self . B = B self . R = R if self . X . shape [ 1 ] != self . R . shape [ 0 ]: raise TestMatrixNonConformabilityException ( \"The number of rows in the test matrix R, does not \" ) X_list = [] y_list = [] tXgXg_list = [] tXgyg_list = [] tXX = np . zeros (( self . k , self . k )) tXy = np . zeros ( self . k ) #all_cluster = np.unique(bootcluster) for g in self . bootclustid : # split X and Y by (boot)cluster X_g = self . X [ np . where ( self . bootcluster == g )] Y_g = self . Y [ np . where ( self . bootcluster == g )] tXgXg = np . transpose ( X_g ) @ X_g tXgyg = np . transpose ( X_g ) @ Y_g X_list . append ( X_g ) y_list . append ( Y_g ) tXgXg_list . append ( tXgXg ) tXgyg_list . append ( tXgyg ) tXX += tXgXg tXy += tXgyg self . X_list = X_list self . Y_list = y_list self . tXgXg_list = tXgXg_list self . tXgyg_list = tXgyg_list self . tXX = tXX self . tXy = tXy self . tXXinv = np . linalg . inv ( tXX ) self . RtXXinv = np . matmul ( R , self . tXXinv )","title":"__init__()"},{"location":"base/#wildboottest.wildboottest.WildboottestCL.get_scores","text":"Run bootstrap and get scores for each variable Parameters: Name Type Description Default bootstrap_type str Determines which wild cluster bootstrap type should be run. Options are \"fnw11\",\"11\", \"13\", \"31\" and \"33\" for the wild cluster bootstrap and \"11\" and \"31\" for the heteroskedastic bootstrap. For more information, see the details section. \"fnw11\" is the default for the cluster bootstrap, which runs a \"11\" type wild cluster bootstrap via the algorithm outlined in \"fast and wild\" (Roodman et al (2019)). \"11\" is the default for the heteroskedastic bootstrap. required impose_null bool Controls if the null hypothesis is imposed on the bootstrap dgp or not. Null imposed (WCR) by default. If False, the null is not imposed (WCU) required adj bool Whether to adjust for small sample. Defaults to True. True cluster_adj bool Whether to do a cluster-robust small sample correction. Defaults to True. True Returns: Type Description np . ndarray np.ndarray: The output array of scores of shape kxG Source code in wildboottest\\wildboottest.py 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 def get_scores ( self , bootstrap_type : str , impose_null : bool , adj : bool = True , cluster_adj : bool = True ) -> np . ndarray : \"\"\"Run bootstrap and get scores for each variable Args: bootstrap_type (str): Determines which wild cluster bootstrap type should be run. Options are \"fnw11\",\"11\", \"13\", \"31\" and \"33\" for the wild cluster bootstrap and \"11\" and \"31\" for the heteroskedastic bootstrap. For more information, see the details section. \"fnw11\" is the default for the cluster bootstrap, which runs a \"11\" type wild cluster bootstrap via the algorithm outlined in \"fast and wild\" (Roodman et al (2019)). \"11\" is the default for the heteroskedastic bootstrap. impose_null (bool): Controls if the null hypothesis is imposed on the bootstrap dgp or not. Null imposed (WCR) by default. If False, the null is not imposed (WCU) adj (bool, optional): Whether to adjust for small sample. Defaults to True. cluster_adj (bool, optional): Whether to do a cluster-robust small sample correction. Defaults to True. Returns: np.ndarray: The output array of scores of shape kxG \"\"\" if bootstrap_type [ 1 : 2 ] == '1' : self . crv_type = \"crv1\" self . ssc = 1 if adj : self . ssc = self . ssc * ( self . N - 1 ) / ( self . N - self . k ) if cluster_adj : self . ssc = self . ssc * self . G / ( self . G - 1 ) elif bootstrap_type [ 1 : 2 ] == '3' : self . crv_type = \"crv3\" self . ssc = ( self . G - 1 ) / self . G bootstrap_type_x = bootstrap_type [ 0 : 1 ] + 'x' if impose_null == True : self . bootstrap_type = \"WCR\" + bootstrap_type_x else : self . bootstrap_type = \"WCU\" + bootstrap_type_x # not needed for all types, but compute anyways self . beta_hat = self . tXXinv @ self . tXy # precompute required objects for computing scores & vcov's if self . bootstrap_type in [ \"WCR3x\" ]: X = self . X X1 = X [:, self . R == 0 ] X1_list = [] tX1gX1g_list = [] tX1gyg_list = [] tXgX1g_list = [] tX1X1 = np . zeros (( self . k - 1 , self . k - 1 )) tX1y = np . zeros ( self . k - 1 ) for ix , g in enumerate ( self . bootclustid ): #ix = g = 1 X1_list . append ( X1 [ np . where ( self . bootcluster == g )]) tX1gX1g_list . append ( np . transpose ( X1_list [ ix ]) @ X1_list [ ix ]) tX1gyg_list . append ( np . transpose ( X1_list [ ix ]) @ self . Y_list [ ix ]) tXgX1g_list . append ( np . transpose ( self . X_list [ ix ]) @ X1_list [ ix ]) tX1X1 = tX1X1 + tX1gX1g_list [ ix ] tX1y = tX1y + tX1gyg_list [ ix ] beta_1g_tilde = [] for ix , g in enumerate ( self . bootclustid ): beta_1g_tilde . append ( np . linalg . pinv ( tX1X1 - tX1gX1g_list [ ix ]) @ ( tX1y - tX1gyg_list [ ix ])) beta = beta_1g_tilde M = tXgX1g_list elif self . bootstrap_type in [ \"WCU3x\" ]: beta_g_hat = [] for ix , g in enumerate ( self . bootclustid ): beta_g_hat . append ( np . linalg . pinv ( self . tXX - self . tXgXg_list [ ix ]) @ ( self . tXy - self . tXgyg_list [ ix ])) beta = beta_g_hat M = self . tXgXg_list elif self . bootstrap_type in [ \"WCR1x\" ]: A = 1 / ( np . transpose ( self . R ) @ self . tXXinv @ self . R ) beta_tilde = self . beta_hat - self . tXXinv @ self . R * A * ( self . R @ self . beta_hat - 0 ) beta = beta_tilde M = self . tXgXg_list elif self . bootstrap_type in [ \"WCU1x\" ]: beta = self . beta_hat M = self . tXgXg_list # compute scores based on tXgyg, M, beta scores_list = [] if ( self . bootstrap_type in [ \"WCR1x\" , \"WCU1x\" ]): for ix , g in enumerate ( self . bootclustid ): scores_list . append ( self . tXgyg_list [ ix ] - M [ ix ] @ beta ) elif ( self . bootstrap_type in [ \"WCR3x\" , \"WCU3x\" ]): for ix , g in enumerate ( self . bootclustid ): scores_list . append ( self . tXgyg_list [ ix ] - M [ ix ] @ beta [ ix ]) self . scores_mat = np . transpose ( np . array ( scores_list )) # k x G return self . scores_mat","title":"get_scores()"},{"location":"base/#wildboottest.wildboottest.WildboottestCL.get_weights","text":"Function for getting weights for bootstrapping. Parameters: Name Type Description Default weights_type Tuple [ str , Callable ] The distribution to be used. Accepts Either 'rademacher', 'mammen', 'norm' or 'webb'. Optionally accepts a callable of one argument, n , the number of bootstraps iterations. required Returns: Type Description Tuple [ np . ndarray , int , bool ] Tuple[np.ndarray, int]: Returns the arrays of weights and the number of bootstrap iterations Source code in wildboottest\\wildboottest.py 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 def get_weights ( self , weights_type : Union [ str , Callable ]) -> Tuple [ np . ndarray , int , bool ]: \"\"\"Function for getting weights for bootstrapping. Args: weights_type (Tuple[str, Callable]): The distribution to be used. Accepts Either 'rademacher', 'mammen', 'norm' or 'webb'. Optionally accepts a callable of one argument, `n`, the number of bootstraps iterations. Returns: Tuple[np.ndarray, int]: Returns the arrays of weights and the number of bootstrap iterations \"\"\" self . weights_type = weights_type if 2 ** self . N_G_bootcluster < self . B and weights_type == 'rademacher' : self . full_enumeration = True full_enumeration_warn = True else : self . full_enumeration = False full_enumeration_warn = False self . v , self . B = draw_weights ( t = self . weights_type , full_enumeration = self . full_enumeration , N_G_bootcluster = self . N_G_bootcluster , boot_iter = self . B ) return self . v , self . B , full_enumeration_warn Create an object of WildboottestHC and get p-value by successively applying methods in the following way: Example import numpy as np from wildboottest.wildboottest import WildboottestHC np.random.seed(12312312) N = 1000 k = 3 G = 10 X = np.random.normal(0, 1, N * k).reshape((N,k)) beta = np.random.normal(0,1,k) beta[0] = 0.005 u = np.random.normal(0,1,N) Y = 1 + X @ beta + u R = np.array([1, 0, 0]) B = 999","title":"get_weights()"},{"location":"base/#wildboottest.wildboottest.WildboottestHC--run-the-wild-bootstrap","text":"wb = WildboottestHC(X = X, Y = Y, R = R, B = B) wb.get_adjustments(bootstrap_type = '11') wb.get_uhat(impose_null = True) wb.get_tboot(weights_type = \"webb\") wb.get_tstat() wb.get_pvalue() Source code in wildboottest\\wildboottest.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 class WildboottestHC : \"\"\" Create an object of WildboottestHC and get p-value by successively applying methods in the following way: Example: >>> import numpy as np >>> from wildboottest.wildboottest import WildboottestHC >>> np.random.seed(12312312) >>> N = 1000 >>> k = 3 >>> G = 10 >>> X = np.random.normal(0, 1, N * k).reshape((N,k)) >>> beta = np.random.normal(0,1,k) >>> beta[0] = 0.005 >>> u = np.random.normal(0,1,N) >>> Y = 1 + X @ beta + u >>> R = np.array([1, 0, 0]) >>> B = 999 >>> # run the wild bootstrap >>> wb = WildboottestHC(X = X, Y = Y, R = R, B = B) >>> wb.get_adjustments(bootstrap_type = '11') >>> wb.get_uhat(impose_null = True) >>> wb.get_tboot(weights_type = \"webb\") >>> wb.get_tstat() >>> wb.get_pvalue() \"\"\" def __init__ ( self , X : Union [ np . ndarray , pd . DataFrame , pd . Series ], Y : Union [ np . ndarray , pd . DataFrame , pd . Series ], R : Union [ np . ndarray , pd . DataFrame ], B : int , seed : Union [ int , None ] = None ) -> None : \"\"\"Initializes the Heteroskedastic Wild Bootstrap Class Args: X (Union[np.ndarray, pd.DataFrame, pd.Series]): Exogeneous variable array or dataframe Y (Union[np.ndarray, pd.DataFrame, pd.Series]): Endogenous variable array or dataframe R (Union[np.ndarray, pd.DataFrame]): Constraint matrix for running bootstrap B (int): bootstrap iterations seed (Union[int, None], optional): Random seed for random weight types. Defaults to None. Raises: TypeError: Raise if input arrays are lists TestMatrixNonConformabilityException: Raise if constraint matrix shape does not conform to X \"\"\" for i in [ X , Y ]: if isinstance ( i , list ): raise TypeError ( f \" { i } cannot be a list\" ) if isinstance ( X , ( pd . DataFrame , pd . Series )): self . X = X . values else : self . X = X if isinstance ( Y , ( pd . DataFrame , pd . Series )): self . Y = Y . values else : self . Y = Y if isinstance ( seed , int ): np . random . seed ( seed ) self . N = X . shape [ 0 ] self . k = X . shape [ 1 ] self . B = B self . R = R if self . X . shape [ 1 ] != self . R . shape [ 0 ]: raise TestMatrixNonConformabilityException ( \"The number of rows in the test matrix R, does not \" ) def get_adjustments ( self , bootstrap_type ): ''' Raises: TestBootstrapTypeException: If non-appropriate bootstrap types are selected ''' if bootstrap_type not in [ '11' , '22' , '33' ]: raise TestBootstrapTypeException ( \"For the heteroskedastic (i.e. non-clustered) wild bootstrap, only types '11', '22' and '33' are supported.\" ) # allow for arbitrary different adjustments for bootstrap and standard t-stat self . tXXinv = np . linalg . inv ( np . transpose ( self . X ) @ self . X ) self . resid_multiplier_boot , self . small_sample_correction = _adjust_scores ( self . X , self . tXXinv , bootstrap_type [ 0 ]) if bootstrap_type [ 0 ] == bootstrap_type [ 1 ]: self . resid_multiplier_stat = self . resid_multiplier_boot else : self . resid_multiplier_stat = _adjust_scores ( self . X , self . tXXinv , bootstrap_type [ 1 ]) def get_uhat ( self , impose_null : bool ): ''' Raises: TestHCImposeNullException: If the null is not imposed on the bootstrap dgp ''' if impose_null is not True : raise TestHCImposeNullException ( 'For the heteroskedastic bootstrap, the null needs to be imposed.' ) self . tXy = np . transpose ( self . X ) @ self . Y self . beta_hat = self . tXXinv @ self . tXy self . uhat = self . Y - self . X @ self . beta_hat self . uhat_stat = self . uhat * self . resid_multiplier_stat if impose_null : self . impose_null = True r = 0 self . beta_r = self . beta_hat - self . tXXinv @ self . R * ( 1 / ( np . transpose ( self . R ) @ self . tXXinv @ self . R )) * ( np . transpose ( self . R ) @ self . beta_hat - r ) #self.uhat_r = self.Y - self.beta_r self . uhat_r = self . Y - self . X @ self . beta_r self . uhat2 = self . uhat_r * self . resid_multiplier_boot else : self . impose_null = False self . uhat2 = self . uhat * self . resid_multiplier_boot def get_tboot ( self , weights_type : Union [ str , Callable ]): if weights_type not in [ 'rademacher' , 'normal' ]: raise TestHCWeightsException ( \"For the heteroskedastic bootstrap, only weight tyes 'rademacher' and 'normal' are supported, but you provided\" + weight_type + \".\" ) self . weights_type = weights_type k = np . where ( self . R == 1 ) self . tXXinvX = self . tXXinv @ np . transpose ( self . X ) if self . impose_null == True : beta = self . beta_r . reshape (( self . k , 1 )) else : beta = self . beta_hat . reshape (( self . k , 1 )) yhat = ( self . X @ beta ) . flatten () R = self . R . reshape (( self . k , 1 )) self . RXXinvX_2 = np . power ( np . transpose ( R ) @ self . tXXinv @ np . transpose ( self . X ), 2 ) #RXXinv_2 = np.power(np.transpose(R) @ self.tXXinv, 2) @njit ( parallel = True ) def _run_hc_bootstrap ( B , weights_type , N , X , yhat , uhat2 , tXXinv , RXXinvX_2 , Rt , small_sample_correction ): #rng = np.random.default_rng() t_boot = np . zeros ( B ) tXXinvX = tXXinv @ np . transpose ( X ) for b in prange ( 0 , B ): # create weights vector. mammen weights not supported via numba v = np . zeros ( N ) if weights_type == 'rademacher' : for i in range ( 0 , N ): v [ i ] = np . random . choice ( np . array ([ - 1 , 1 ])) else : v = np . zeros ( N ) for i in range ( 0 , N ): v [ i ] = np . random . normal () uhat_boot = uhat2 * v yhat_boot = yhat + uhat_boot beta_boot = tXXinvX @ yhat_boot resid_boot = yhat_boot - X @ beta_boot cov_v = small_sample_correction * RXXinvX_2 @ np . power ( resid_boot , 2 ) t_boot [ b ] = ( Rt @ beta_boot / np . sqrt ( cov_v ))[ 0 ] return t_boot self . t_boot = _run_hc_bootstrap ( B = self . B , weights_type = self . weights_type , N = self . N , X = self . X , yhat = yhat , uhat2 = self . uhat2 , tXXinv = self . tXXinv , RXXinvX_2 = self . RXXinvX_2 , Rt = np . transpose ( R ), small_sample_correction = self . small_sample_correction ) def get_tstat ( self ): cov = self . small_sample_correction * self . RXXinvX_2 @ np . power ( self . uhat_stat , 2 ) self . t_stat = ( np . transpose ( self . R ) @ self . beta_hat / np . sqrt ( cov )) def get_pvalue ( self , pval_type = \"two-tailed\" ): if pval_type == \"two-tailed\" : self . pvalue = np . mean ( np . abs ( self . t_stat ) < abs ( self . t_boot )) elif pval_type == \"equal-tailed\" : pl = np . mean ( self . t_stat < self . t_boot ) ph = np . mean ( self . t_stat > self . t_boot ) self . pvalue = 2 * min ( pl , ph ) elif pval_type == \">\" : self . pvalue = np . mean ( self . t_stat < self . t_boot ) else : self . pvalue = np . mean ( self . t_stat > self . t_boot )","title":"run the wild bootstrap"},{"location":"base/#wildboottest.wildboottest.WildboottestHC.__init__","text":"Initializes the Heteroskedastic Wild Bootstrap Class Parameters: Name Type Description Default X Union [ np . ndarray , pd . DataFrame , pd . Series ] Exogeneous variable array or dataframe required Y Union [ np . ndarray , pd . DataFrame , pd . Series ] Endogenous variable array or dataframe required R Union [ np . ndarray , pd . DataFrame ] Constraint matrix for running bootstrap required B int bootstrap iterations required seed Union [ int , None] Random seed for random weight types. Defaults to None. None Raises: Type Description TypeError Raise if input arrays are lists TestMatrixNonConformabilityException Raise if constraint matrix shape does not conform to X Source code in wildboottest\\wildboottest.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def __init__ ( self , X : Union [ np . ndarray , pd . DataFrame , pd . Series ], Y : Union [ np . ndarray , pd . DataFrame , pd . Series ], R : Union [ np . ndarray , pd . DataFrame ], B : int , seed : Union [ int , None ] = None ) -> None : \"\"\"Initializes the Heteroskedastic Wild Bootstrap Class Args: X (Union[np.ndarray, pd.DataFrame, pd.Series]): Exogeneous variable array or dataframe Y (Union[np.ndarray, pd.DataFrame, pd.Series]): Endogenous variable array or dataframe R (Union[np.ndarray, pd.DataFrame]): Constraint matrix for running bootstrap B (int): bootstrap iterations seed (Union[int, None], optional): Random seed for random weight types. Defaults to None. Raises: TypeError: Raise if input arrays are lists TestMatrixNonConformabilityException: Raise if constraint matrix shape does not conform to X \"\"\" for i in [ X , Y ]: if isinstance ( i , list ): raise TypeError ( f \" { i } cannot be a list\" ) if isinstance ( X , ( pd . DataFrame , pd . Series )): self . X = X . values else : self . X = X if isinstance ( Y , ( pd . DataFrame , pd . Series )): self . Y = Y . values else : self . Y = Y if isinstance ( seed , int ): np . random . seed ( seed ) self . N = X . shape [ 0 ] self . k = X . shape [ 1 ] self . B = B self . R = R if self . X . shape [ 1 ] != self . R . shape [ 0 ]: raise TestMatrixNonConformabilityException ( \"The number of rows in the test matrix R, does not \" )","title":"__init__()"},{"location":"base/#wildboottest.wildboottest.WildboottestHC.get_adjustments","text":"Raises: TestBootstrapTypeException: If non-appropriate bootstrap types are selected Source code in wildboottest\\wildboottest.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 def get_adjustments ( self , bootstrap_type ): ''' Raises: TestBootstrapTypeException: If non-appropriate bootstrap types are selected ''' if bootstrap_type not in [ '11' , '22' , '33' ]: raise TestBootstrapTypeException ( \"For the heteroskedastic (i.e. non-clustered) wild bootstrap, only types '11', '22' and '33' are supported.\" ) # allow for arbitrary different adjustments for bootstrap and standard t-stat self . tXXinv = np . linalg . inv ( np . transpose ( self . X ) @ self . X ) self . resid_multiplier_boot , self . small_sample_correction = _adjust_scores ( self . X , self . tXXinv , bootstrap_type [ 0 ]) if bootstrap_type [ 0 ] == bootstrap_type [ 1 ]: self . resid_multiplier_stat = self . resid_multiplier_boot else : self . resid_multiplier_stat = _adjust_scores ( self . X , self . tXXinv , bootstrap_type [ 1 ])","title":"get_adjustments()"},{"location":"base/#wildboottest.wildboottest.WildboottestHC.get_uhat","text":"Raises: TestHCImposeNullException: If the null is not imposed on the bootstrap dgp Source code in wildboottest\\wildboottest.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def get_uhat ( self , impose_null : bool ): ''' Raises: TestHCImposeNullException: If the null is not imposed on the bootstrap dgp ''' if impose_null is not True : raise TestHCImposeNullException ( 'For the heteroskedastic bootstrap, the null needs to be imposed.' ) self . tXy = np . transpose ( self . X ) @ self . Y self . beta_hat = self . tXXinv @ self . tXy self . uhat = self . Y - self . X @ self . beta_hat self . uhat_stat = self . uhat * self . resid_multiplier_stat if impose_null : self . impose_null = True r = 0 self . beta_r = self . beta_hat - self . tXXinv @ self . R * ( 1 / ( np . transpose ( self . R ) @ self . tXXinv @ self . R )) * ( np . transpose ( self . R ) @ self . beta_hat - r ) #self.uhat_r = self.Y - self.beta_r self . uhat_r = self . Y - self . X @ self . beta_r self . uhat2 = self . uhat_r * self . resid_multiplier_boot else : self . impose_null = False self . uhat2 = self . uhat * self . resid_multiplier_boot","title":"get_uhat()"},{"location":"library_apis/","text":"Library APIs Statsmodels Run a wild cluster bootstrap based on an object of class 'statsmodels.regression.linear_model.OLS' Parameters: Name Type Description Default model OLS A statsmodels regression object required B int The number of bootstrap iterations to run cluster (Union[None, np.ndarray, pd.Series, pd.DataFrame], optional): If None (default), a 'heteroskedastic' wild boostrap is run. For a wild cluster bootstrap, requires a numpy array of dimension one,a pandas Series or DataFrame, containing the clustering variable. required param Union [ str , None] A string of length one, containing the test parameter of interest. Defaults to None. None weights_type str The type of bootstrap weights. Either 'rademacher', 'mammen', 'webb' or 'normal'. 'rademacher' by default. Defaults to 'rademacher'. 'rademacher' impose_null bool Should the null hypothesis be imposed on the bootstrap dgp, or not? Defaults to True. True bootstrap_type str A string of length one. Allows to choose the bootstrap type to be run. Either '11', '31', '13' or '33'. '11' by default. Defaults to '11'. '11' seed Union [ str , None] Option to provide a random seed. Defaults to None. None Raises: Type Description Exception Raises if param is not a string Returns: Type Description pd . DataFrame pd.DataFrame: A wild cluster bootstrapped p-value(s). pd . DataFrame Example: >>> from wildboottest.wildboottest import wildboottest >>> import statsmodels.api as sm >>> import numpy as np >>> import pandas as pd >>> np.random.seed(12312312) >>> N = 1000 >>> k = 10 >>> G = 10 >>> X = np.random.normal(0, 1, N * k).reshape((N,k)) >>> X = pd.DataFrame(X) >>> X.rename(columns = {0:\"X1\"}, inplace = True) >>> beta = np.random.normal(0,1,k) >>> beta[0] = 0.005 >>> u = np.random.normal(0,1,N) >>> Y = 1 + X @ beta + u >>> cluster = np.random.choice(list(range(0,G)), N) >>> model = sm.OLS(Y, X) >>> wildboottest(model, param = \"X1\", B = 9999) >>> wildboottest(model, param = \"X1\", cluster = cluster, B = 9999) >>> wildboottest(model, cluster = cluster, B = 9999) Source code in wildboottest\\wildboottest.py 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 def wildboottest ( model : 'OLS' , B : int , cluster : Union [ np . ndarray , pd . Series , pd . DataFrame , None ] = None , param : Union [ str , None ] = None , weights_type : str = 'rademacher' , impose_null : bool = True , bootstrap_type : str = '11' , seed : Union [ str , None ] = None , adj : bool = True , cluster_adj : bool = True , show = True ) -> pd . DataFrame : \"\"\"Run a wild cluster bootstrap based on an object of class 'statsmodels.regression.linear_model.OLS' Args: model (OLS): A statsmodels regression object B (int): The number of bootstrap iterations to run cluster (Union[None, np.ndarray, pd.Series, pd.DataFrame], optional): If None (default), a 'heteroskedastic' wild boostrap is run. For a wild cluster bootstrap, requires a numpy array of dimension one,a pandas Series or DataFrame, containing the clustering variable. param (Union[str, None], optional): A string of length one, containing the test parameter of interest. Defaults to None. weights_type (str, optional): The type of bootstrap weights. Either 'rademacher', 'mammen', 'webb' or 'normal'. 'rademacher' by default. Defaults to 'rademacher'. impose_null (bool, optional): Should the null hypothesis be imposed on the bootstrap dgp, or not? Defaults to True. bootstrap_type (str, optional):A string of length one. Allows to choose the bootstrap type to be run. Either '11', '31', '13' or '33'. '11' by default. Defaults to '11'. seed (Union[str, None], optional): Option to provide a random seed. Defaults to None. Raises: Exception: Raises if `param` is not a string Returns: pd.DataFrame: A wild cluster bootstrapped p-value(s). Example: >>> from wildboottest.wildboottest import wildboottest >>> import statsmodels.api as sm >>> import numpy as np >>> import pandas as pd >>> np.random.seed(12312312) >>> N = 1000 >>> k = 10 >>> G = 10 >>> X = np.random.normal(0, 1, N * k).reshape((N,k)) >>> X = pd.DataFrame(X) >>> X.rename(columns = {0:\"X1\"}, inplace = True) >>> beta = np.random.normal(0,1,k) >>> beta[0] = 0.005 >>> u = np.random.normal(0,1,N) >>> Y = 1 + X @ beta + u >>> cluster = np.random.choice(list(range(0,G)), N) >>> model = sm.OLS(Y, X) >>> wildboottest(model, param = \"X1\", B = 9999) >>> wildboottest(model, param = \"X1\", cluster = cluster, B = 9999) >>> wildboottest(model, cluster = cluster, B = 9999) \"\"\" # does model.exog already exclude missing values? X = model . exog # interestingly, the dependent variable is called 'endogeneous' Y = model . endog # weights not yet used, only as a placeholder weights = model . weights xnames = model . data . xnames ynames = model . data . ynames pvalues = [] tstats = [] def generate_stats ( param , cluster ): R = np . zeros ( len ( xnames )) R [ xnames . index ( param )] = 1 # Just test for beta=0 # is it possible to fetch the clustering variables from the pre-processed data # frame, e.g. with 'excluding' observations with missings etc # cluster = ... if cluster is None : boot = WildboottestHC ( X = X , Y = Y , R = R , B = B , seed = seed ) boot . get_adjustments ( bootstrap_type = bootstrap_type ) boot . get_uhat ( impose_null = impose_null ) boot . get_tboot ( weights_type = weights_type ) boot . get_tstat () boot . get_pvalue ( pval_type = \"two-tailed\" ) full_enumeration_warn = False else : print ( 'Estimate wild cluster bootstrap: ' ) boot = WildboottestCL ( X = X , Y = Y , cluster = cluster , R = R , B = B , seed = seed ) boot . get_scores ( bootstrap_type = bootstrap_type , impose_null = impose_null , adj = adj , cluster_adj = cluster_adj ) _ , _ , full_enumeration_warn = boot . get_weights ( weights_type = weights_type ) boot . get_numer () boot . get_denom () boot . get_tboot () boot . get_vcov () boot . get_tstat () boot . get_pvalue ( pval_type = \"two-tailed\" ) pvalues . append ( boot . pvalue ) tstats . append ( boot . t_stat [ 0 ]) return pvalues , tstats , full_enumeration_warn if param is None : for x in xnames : pvalues , tstats , full_enumeration_warn = generate_stats ( x , cluster = cluster ) param = xnames elif isinstance ( param , str ): pvalues , tstats , full_enumeration_warn = generate_stats ( param , cluster = cluster ) else : raise Exception ( \"`param` not correctly specified\" ) if full_enumeration_warn : warnings . warn ( \"2^G < the number of boot iterations, setting full_enumeration to True.\" ) res = { 'param' : param , 'statistic' : tstats , 'p-value' : pvalues } res_df = pd . DataFrame ( res ) . set_index ( 'param' ) if show : print ( res_df . to_markdown ( floatfmt = \".3f\" )) return res_df","title":"Library APIs"},{"location":"library_apis/#library-apis","text":"","title":"Library APIs"},{"location":"library_apis/#statsmodels","text":"Run a wild cluster bootstrap based on an object of class 'statsmodels.regression.linear_model.OLS' Parameters: Name Type Description Default model OLS A statsmodels regression object required B int The number of bootstrap iterations to run cluster (Union[None, np.ndarray, pd.Series, pd.DataFrame], optional): If None (default), a 'heteroskedastic' wild boostrap is run. For a wild cluster bootstrap, requires a numpy array of dimension one,a pandas Series or DataFrame, containing the clustering variable. required param Union [ str , None] A string of length one, containing the test parameter of interest. Defaults to None. None weights_type str The type of bootstrap weights. Either 'rademacher', 'mammen', 'webb' or 'normal'. 'rademacher' by default. Defaults to 'rademacher'. 'rademacher' impose_null bool Should the null hypothesis be imposed on the bootstrap dgp, or not? Defaults to True. True bootstrap_type str A string of length one. Allows to choose the bootstrap type to be run. Either '11', '31', '13' or '33'. '11' by default. Defaults to '11'. '11' seed Union [ str , None] Option to provide a random seed. Defaults to None. None Raises: Type Description Exception Raises if param is not a string Returns: Type Description pd . DataFrame pd.DataFrame: A wild cluster bootstrapped p-value(s). pd . DataFrame Example: >>> from wildboottest.wildboottest import wildboottest >>> import statsmodels.api as sm >>> import numpy as np >>> import pandas as pd >>> np.random.seed(12312312) >>> N = 1000 >>> k = 10 >>> G = 10 >>> X = np.random.normal(0, 1, N * k).reshape((N,k)) >>> X = pd.DataFrame(X) >>> X.rename(columns = {0:\"X1\"}, inplace = True) >>> beta = np.random.normal(0,1,k) >>> beta[0] = 0.005 >>> u = np.random.normal(0,1,N) >>> Y = 1 + X @ beta + u >>> cluster = np.random.choice(list(range(0,G)), N) >>> model = sm.OLS(Y, X) >>> wildboottest(model, param = \"X1\", B = 9999) >>> wildboottest(model, param = \"X1\", cluster = cluster, B = 9999) >>> wildboottest(model, cluster = cluster, B = 9999) Source code in wildboottest\\wildboottest.py 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 def wildboottest ( model : 'OLS' , B : int , cluster : Union [ np . ndarray , pd . Series , pd . DataFrame , None ] = None , param : Union [ str , None ] = None , weights_type : str = 'rademacher' , impose_null : bool = True , bootstrap_type : str = '11' , seed : Union [ str , None ] = None , adj : bool = True , cluster_adj : bool = True , show = True ) -> pd . DataFrame : \"\"\"Run a wild cluster bootstrap based on an object of class 'statsmodels.regression.linear_model.OLS' Args: model (OLS): A statsmodels regression object B (int): The number of bootstrap iterations to run cluster (Union[None, np.ndarray, pd.Series, pd.DataFrame], optional): If None (default), a 'heteroskedastic' wild boostrap is run. For a wild cluster bootstrap, requires a numpy array of dimension one,a pandas Series or DataFrame, containing the clustering variable. param (Union[str, None], optional): A string of length one, containing the test parameter of interest. Defaults to None. weights_type (str, optional): The type of bootstrap weights. Either 'rademacher', 'mammen', 'webb' or 'normal'. 'rademacher' by default. Defaults to 'rademacher'. impose_null (bool, optional): Should the null hypothesis be imposed on the bootstrap dgp, or not? Defaults to True. bootstrap_type (str, optional):A string of length one. Allows to choose the bootstrap type to be run. Either '11', '31', '13' or '33'. '11' by default. Defaults to '11'. seed (Union[str, None], optional): Option to provide a random seed. Defaults to None. Raises: Exception: Raises if `param` is not a string Returns: pd.DataFrame: A wild cluster bootstrapped p-value(s). Example: >>> from wildboottest.wildboottest import wildboottest >>> import statsmodels.api as sm >>> import numpy as np >>> import pandas as pd >>> np.random.seed(12312312) >>> N = 1000 >>> k = 10 >>> G = 10 >>> X = np.random.normal(0, 1, N * k).reshape((N,k)) >>> X = pd.DataFrame(X) >>> X.rename(columns = {0:\"X1\"}, inplace = True) >>> beta = np.random.normal(0,1,k) >>> beta[0] = 0.005 >>> u = np.random.normal(0,1,N) >>> Y = 1 + X @ beta + u >>> cluster = np.random.choice(list(range(0,G)), N) >>> model = sm.OLS(Y, X) >>> wildboottest(model, param = \"X1\", B = 9999) >>> wildboottest(model, param = \"X1\", cluster = cluster, B = 9999) >>> wildboottest(model, cluster = cluster, B = 9999) \"\"\" # does model.exog already exclude missing values? X = model . exog # interestingly, the dependent variable is called 'endogeneous' Y = model . endog # weights not yet used, only as a placeholder weights = model . weights xnames = model . data . xnames ynames = model . data . ynames pvalues = [] tstats = [] def generate_stats ( param , cluster ): R = np . zeros ( len ( xnames )) R [ xnames . index ( param )] = 1 # Just test for beta=0 # is it possible to fetch the clustering variables from the pre-processed data # frame, e.g. with 'excluding' observations with missings etc # cluster = ... if cluster is None : boot = WildboottestHC ( X = X , Y = Y , R = R , B = B , seed = seed ) boot . get_adjustments ( bootstrap_type = bootstrap_type ) boot . get_uhat ( impose_null = impose_null ) boot . get_tboot ( weights_type = weights_type ) boot . get_tstat () boot . get_pvalue ( pval_type = \"two-tailed\" ) full_enumeration_warn = False else : print ( 'Estimate wild cluster bootstrap: ' ) boot = WildboottestCL ( X = X , Y = Y , cluster = cluster , R = R , B = B , seed = seed ) boot . get_scores ( bootstrap_type = bootstrap_type , impose_null = impose_null , adj = adj , cluster_adj = cluster_adj ) _ , _ , full_enumeration_warn = boot . get_weights ( weights_type = weights_type ) boot . get_numer () boot . get_denom () boot . get_tboot () boot . get_vcov () boot . get_tstat () boot . get_pvalue ( pval_type = \"two-tailed\" ) pvalues . append ( boot . pvalue ) tstats . append ( boot . t_stat [ 0 ]) return pvalues , tstats , full_enumeration_warn if param is None : for x in xnames : pvalues , tstats , full_enumeration_warn = generate_stats ( x , cluster = cluster ) param = xnames elif isinstance ( param , str ): pvalues , tstats , full_enumeration_warn = generate_stats ( param , cluster = cluster ) else : raise Exception ( \"`param` not correctly specified\" ) if full_enumeration_warn : warnings . warn ( \"2^G < the number of boot iterations, setting full_enumeration to True.\" ) res = { 'param' : param , 'statistic' : tstats , 'p-value' : pvalues } res_df = pd . DataFrame ( res ) . set_index ( 'param' ) if show : print ( res_df . to_markdown ( floatfmt = \".3f\" )) return res_df","title":"Statsmodels"},{"location":"weights/","text":"Weights draw_weights ( t , full_enumeration , N_G_bootcluster , boot_iter ) draw bootstrap weights Parameters: Name Type Description Default t str | callable the type of the weights distribution. Either 'rademacher', 'mammen', 'norm' or 'webb' required full_enumeration bool should deterministic full enumeration be employed required N_G_bootcluster int the number of bootstrap clusters required boot_iter int the number of bootstrap iterations required Returns: Type Description Tuple [ np . ndarray , int ] Tuple[np.ndarray, int]: a matrix of dimension N_G_bootcluster x (boot_iter + 1) and the number of iterations Source code in wildboottest\\weights.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def draw_weights ( t : Union [ str , Callable ], full_enumeration : bool , N_G_bootcluster : int , boot_iter : int ) -> Tuple [ np . ndarray , int ]: \"\"\"draw bootstrap weights Args: t (str|callable): the type of the weights distribution. Either 'rademacher', 'mammen', 'norm' or 'webb' If `t` is a callable, must be a function of one variable, `n`, and return a vector of size `n` full_enumeration (bool): should deterministic full enumeration be employed N_G_bootcluster (int): the number of bootstrap clusters boot_iter (int): the number of bootstrap iterations Returns: Tuple[np.ndarray, int]: a matrix of dimension N_G_bootcluster x (boot_iter + 1) and the number of iterations \"\"\" #TODO: we can use the `case` feature in python, but that's only available in 3.10+ will do a 3.7 version for now # Will take out this and make separate functions for readability if isinstance ( t , str ): wild_draw_fun = wild_draw_fun_dict . get ( t ) if wild_draw_fun is None : raise WildDrawFunctionException ( \"Function type specified is not supported or there is a typo.\" ) elif callable ( t ): wild_draw_fun = t elif t is None : raise WildDrawFunctionException ( \"`t` must be specified\" ) else : raise ValueError ( f \"t can be string or callable, but got { type ( t ) } \" ) # do full enumeration for rademacher weights if bootstrap iterations # B exceed number of possible permutations else random sampling # full_enumeration only for rademacher weights (set earlier) if full_enumeration : t = 0 # what is this needed for? # with N_G_bootcluster draws, get all combinations of [-1,1] WITH # replacement, in matrix form v0 = np . transpose ( np . array ( list ( product ([ - 1 , 1 ], repeat = N_G_bootcluster )))) else : # else: just draw with replacement - by chance, some permutations # might occur more than once v0 = wild_draw_fun ( n = N_G_bootcluster * boot_iter ) v0 = v0 . reshape ( N_G_bootcluster , boot_iter ) # weights matrix # update boot_iter (B) - only relevant in enumeration case boot_iter = v0 . shape [ 1 ] #v = np.insert(v0, 0, 1,axis = 1) return v0 , boot_iter","title":"Weighting"},{"location":"weights/#weights","text":"","title":"Weights"},{"location":"weights/#wildboottest.weights.draw_weights","text":"draw bootstrap weights Parameters: Name Type Description Default t str | callable the type of the weights distribution. Either 'rademacher', 'mammen', 'norm' or 'webb' required full_enumeration bool should deterministic full enumeration be employed required N_G_bootcluster int the number of bootstrap clusters required boot_iter int the number of bootstrap iterations required Returns: Type Description Tuple [ np . ndarray , int ] Tuple[np.ndarray, int]: a matrix of dimension N_G_bootcluster x (boot_iter + 1) and the number of iterations Source code in wildboottest\\weights.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def draw_weights ( t : Union [ str , Callable ], full_enumeration : bool , N_G_bootcluster : int , boot_iter : int ) -> Tuple [ np . ndarray , int ]: \"\"\"draw bootstrap weights Args: t (str|callable): the type of the weights distribution. Either 'rademacher', 'mammen', 'norm' or 'webb' If `t` is a callable, must be a function of one variable, `n`, and return a vector of size `n` full_enumeration (bool): should deterministic full enumeration be employed N_G_bootcluster (int): the number of bootstrap clusters boot_iter (int): the number of bootstrap iterations Returns: Tuple[np.ndarray, int]: a matrix of dimension N_G_bootcluster x (boot_iter + 1) and the number of iterations \"\"\" #TODO: we can use the `case` feature in python, but that's only available in 3.10+ will do a 3.7 version for now # Will take out this and make separate functions for readability if isinstance ( t , str ): wild_draw_fun = wild_draw_fun_dict . get ( t ) if wild_draw_fun is None : raise WildDrawFunctionException ( \"Function type specified is not supported or there is a typo.\" ) elif callable ( t ): wild_draw_fun = t elif t is None : raise WildDrawFunctionException ( \"`t` must be specified\" ) else : raise ValueError ( f \"t can be string or callable, but got { type ( t ) } \" ) # do full enumeration for rademacher weights if bootstrap iterations # B exceed number of possible permutations else random sampling # full_enumeration only for rademacher weights (set earlier) if full_enumeration : t = 0 # what is this needed for? # with N_G_bootcluster draws, get all combinations of [-1,1] WITH # replacement, in matrix form v0 = np . transpose ( np . array ( list ( product ([ - 1 , 1 ], repeat = N_G_bootcluster )))) else : # else: just draw with replacement - by chance, some permutations # might occur more than once v0 = wild_draw_fun ( n = N_G_bootcluster * boot_iter ) v0 = v0 . reshape ( N_G_bootcluster , boot_iter ) # weights matrix # update boot_iter (B) - only relevant in enumeration case boot_iter = v0 . shape [ 1 ] #v = np.insert(v0, 0, 1,axis = 1) return v0 , boot_iter","title":"draw_weights()"}]}