---
title: "development notebook"
author: "Alexander Fischer"
date: "2022-09-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## in R

... create all required input parameters for `boot_algo()` functions

```{r, warning=FALSE, message = FALSE}
library(fixest)
library(reticulate)

path_to_fwildclusterboot <- "C:/Users/alexa/Dropbox/fwildclusterboot"
devtools::load_all(path_to_fwildclusterboot)


# create the data set
N_G1 <- 50
data2 <- fwildclusterboot:::create_data(N = 10000,
                                         N_G1 = N_G1,
                                         icc1 = 0.8,
                                         N_G2 = N_G1,
                                         icc2 = 0.8,
                                         numb_fe1 = 10,
                                         numb_fe2 = 5,
                                         seed = 41224,
                                         #seed = 123,
                                         weights = 1:N / N)

data2$group_id1 <- as.factor(data2$group_id1)

ssc <- ssc(adj = FALSE, cluster.adj = FALSE, cluster.df = "min", fixef.K = "none")
boot_ssc <- boot_ssc(adj = FALSE, cluster.adj = FALSE, cluster.df = "min", fixef.K = "none")

boot_algo <- "R"
clustid <- cluster <-  c("group_id2")
param = "log_income"
R <- NULL
r <-  0
beta0 <- NULL
B <- boot_iter <-  999
bootcluster =  "min"
fe = NULL
sign_level = NULL
conf_int = NULL
seed = NULL
# beta0 = 0.1
type = "rademacher"
impose_null = TRUE
p_val_type = NULL
tol = 1e-6
maxiter = 10
na_omit = TRUE
nthreads = 1
sign_level = 0.05
# full_enumeration = FAL
floattype = "Float64"
p_val_type = "two-tailed"
getauxweights = FALSE
turbo = FALSE
bootstrapc = FALSE
maxmatsize = NULL

engine = "R"
bootstrap_type = "11"

object <- feols(proposition_vote ~ treatment + log_income + as.factor(group_id1), cluster = ~group_id1, data = voters)
```

run the first part of `boottest.fixest()`

```{r, warning = FALSE, message = FALSE}
  if (!is.null(beta0)) {
    stop(
      "The function argument 'beta0' is deprecated. Please use the
      function argument 'r' instead, by which it is replaced."
    )
  }
  
  if (inherits(clustid, "formula")) {
    clustid <- attr(terms(clustid), "term.labels")
  }
  
  if (inherits(bootcluster, "formula")) {
    bootcluster <- attr(terms(bootcluster), "term.labels")
  }
  
  if (inherits(param, "formula")) {
    param <- attr(terms(param), "term.labels")
  }
  
  if (inherits(fe, "formula")) {
    fe <- attr(terms(fe), "term.labels")
  }
  
  internal_seed <- set_seed(
    seed = seed,
    engine = engine,
    type = type
  )
  
  if (!is.null(object$fixef_removed)) {
    stop(
      paste(
        "feols() removes fixed effects with the following values: ",
        object$fixef_removed,
        ". Currently, boottest()'s internal pre-processing does not
        account for this deletion. Therefore, please exclude such fixed
        effects prior to estimation with feols(). You can find them listed
        under '$fixef_removed' of your fixest object."
      )
    )
  }
  
  # --------------------------------------------
  
  # check appropriateness of nthreads
  nthreads <- check_set_nthreads(nthreads)
  
  if (is.null(clustid)) {
    heteroskedastic <- TRUE
    if (engine == "R") {
      # heteroskedastic models should always be run through R-lean
      engine <- "R-lean"
    }
  } else {
    heteroskedastic <- FALSE
  }
  
  
  R_long <- process_R(
    R = R,
    param = param
  )
  
  
  if (engine != "WildBootTests.jl") {
    r_algo_checks(
      R = R_long,
      p_val_type = p_val_type,
      conf_int = conf_int,
      B = B
    )
  }
  
  # check_params_in_model(object = object, param = param)
  
  check_boottest_args_plus(
    object = object,
    R = R_long,
    param = param,
    sign_level = sign_level,
    B = B,
    fe = fe
  )
  
  # preprocess the data: Y, X, weights, fixed_effect
  preprocess <- preprocess2.fixest(
    object = object,
    clustid = clustid,
    R = R_long,
    param = param,
    bootcluster = bootcluster,
    fe = fe,
    engine = engine
  )
  
  enumerate <-
    check_set_full_enumeration(
      preprocess = preprocess,
      heteroskedastic = heteroskedastic,
      B = B,
      type = type,
      engine = engine
    )
  full_enumeration <- enumerate$full_enumeration
  B <- enumerate$B
  
  N <- preprocess$N
  k <- preprocess$k
  G <-
    vapply(preprocess$clustid, function(x) {
      length(unique(x))
    }, numeric(1))
  vcov_sign <- preprocess$vcov_sign
  
  small_sample_correction <-
    get_ssc(
      boot_ssc_object = ssc,
      N = N,
      k = k,
      G = G,
      vcov_sign = vcov_sign,
      heteroskedastic = heteroskedastic
    )
  
  # clustermin, clusteradj
  
  
  clustid_dims <- preprocess$clustid_dims
  # R*beta;
  point_estimate <-
    as.vector(object$coefficients[param] %*% preprocess$R0[param])
  
  boot_vcov <- boot_coef <- NULL

```

make all objects from `preprocess()` available in the global namespace

```{r, warning = FALSE, message = FALSE}
res <- lapply(names(preprocess), function(x) assign(x, preprocess[[x]], envir = .GlobalEnv))
bootcluster <- as.vector(bootcluster)[[1]]
```

## pass all values to python

via the `reticulate` package

```{python}
import numpy as np
import pandas as pd

X = np.array(r.X)
y = np.array(r.Y)
#clustid_df = r.clustid_df
bootstrap_type = r.bootstrap_type
N_G_bootcluster = r.N_G_bootcluster
bootcluster = np.array(r.bootcluster)
clusters = np.array(bootcluster)
R = np.array(r.R0)
impose_null = True
B = int(r.boot_iter)
ssc = int(r.small_sample_correction)

pval_type = r.p_val_type

type(X)
X[0:10, 0:10]

```
develop ... 



